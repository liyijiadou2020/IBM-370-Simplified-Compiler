#pragma once
#include <stdio.h>
#include <string.h>

#define MAXNISXTXT 50
// #define NSINT     201
#define NSINT     301
#define NCEL       20
#define NDST      500
#define NVXOD      53
#define NSTROKA   200
#define NNETRM     17
#define MAXLTXT    50
#define MAXFORMT   30
#define NSYM      100
#define FILE_NOT_OPEN -2
#define WRITE_FILE_FAILED -2

int idx_of_VXOD(const char* T1, int T2);


FILE* fp_out;                                  /* 用于写出到log.txt */

/*
***** Б а з а  данных компилятора
*/

/*
***** Б л о к  об'явления массива с исходным текстом
*/

int  NISXTXT;                                     /* длина массива          */
char ISXTXT[MAXNISXTXT][80];                      /* тело массива           */

/*
***** Б л о к  об'явления рабочих переменных
*/

int I1, I2, I3, I4;                                  /* счетчики циклов        */

char PREDSYM = ' ';                               /*последний обработанный  */
/*символ в уплотненном    */
/*исходном тексте         */

char STROKA[NSTROKA];                          /*место хранения уплотненного исходного текста*/

int I, J, K, L;                                      /*текущие индексы соответ-*/
/*ственно в:              */
/* - уплотненном тексте;  */
/* - табл.грамм.правил;   */
/* - стеке поставленных целей; */
/* - стеке достигнутых целей; */

union                                             /*шаблон для генерации записи выходного файла на АССЕМБЛЕРЕ IBM 370 */
{
  char    BUFCARD[80];
  struct
  {
    char METKA[8];
    char PROB1;
    char OPERAC[5];
    char PROB2;
    char OPERAND[12];
    char PROB3;
    char COMM[52];
  } _BUFCARD;
} ASS_CARD;


char ASSTXT[MAXLTXT][80];                      /*массив для хранения     */
/*выходного текста на     */
/*АССЕМБЛЕРЕ IBM 370      */


int  IASSTXT;                                     /*индекс выходного массива*/

char FORMT[MAXFORMT][9];                        /*массив для форматирован-*/
/*ного  (в виде последова-*/
/*тельности 9-ти позицион-*/
/*ных строк-лексем) пред- */
/*ставления интерпретиру- */
/*емого фрагмента исходно-*/
/*го плотного текста      */

int  IFORMT;                                      /*индекс форматированного */
/*массива                 */
/*
***** Б л о к  об'явления таблиц базы данных
*/

/*
***** Т а б л и ц а, используемая как магазин (стек) достижений
*/

struct
{
  char DST1[4];
  int  DST2;
  int  DST3;
  int  DST4;
  int  DST5;
} DST[NDST];

/*
***** Т а б л и ц а, используемая как магазин (стек) целей
*/

struct
{
  char CEL1[4]; /* 非终结符 */
  int  CEL2;    /* 在原文本中的开头坐标 */
  int  CEL3;    /* 在入口表中的索引 */
} CEL[NCEL];

/*
***** Т а б л и ц а, синтаксических правил, записанных в форме распознавания,
***** сгруппированных в "кусты" и представленных в виде двухнапрвленного
***** списка с альтернативными разветвлениями
*/

struct
{
  int  POSL;    /* структурный адрес правого смежного узла графа (столбец "последователь" с идентификатором POSL)*/
  int  PRED;    /* структурный адрес левого смежного узла графа (столбец "предшественник" с идентификатором PRED),*/
  char DER[4];  /* обозначение символа (столбец "символ" с идентификатором GRAF), совпадающее со значением символа, указанным в верхней части изображения узла графа,*/
  int  ALT;     /* структурный адрес альтернативного узла графа (столбец "альтернатива" с идентификатором ALT).*/
} SINT[NSINT] =
/*   __________ _________ _______ _______ ______
    |  NN      :    посл : пред  :  дер  : альт |
    |__________:_________:_______:_______:______|                          */
{
  {/*.    0     .*/    -1 ,    -1 , "***" ,   -1 },
   /*                                               вход с символа - 0      */
  {/*.    1     .*/     2 ,     0 , "0  " ,    0 },
  {/*.    2     .*/     3 ,     1 , "CIF" ,    0 },
  {/*.    3     .*/     0 ,     2 , "*  " ,    0 },
  /*                                               вход с символа - 1      */
  {/*.    4     .*/     5 ,     0 , "1  " ,    0 },
  {/*.    5     .*/     6 ,     4 , "CIF" ,    7 },
  {/*.    6     .*/     0 ,     5 , "*  " ,    0 },

  {/*.    7     .*/     8 ,     4 , "MAN" ,    0 },
  {/*.    8     .*/     0 ,     7 , "*  " ,    0 },
  /*                                               вход с символа - 2      */
  {/*.    9     .*/    10 ,     0 , "2  " ,    0 },
  {/*.   10     .*/    11 ,     9 , "CIF" ,    0 },
  {/*.   11     .*/     0 ,    10 , "*  " ,    0 },
  /*                                               вход с символа - 3      */
  {/*.   12     .*/    13 ,     0 , "3  " ,    0 },
  {/*.   13     .*/    14 ,    12 , "CIF" ,    0 },
  {/*.   14     .*/     0 ,    13 , "*  " ,    0 },
  /*                                               вход с символа - 4      */
  {/*.   15     .*/    16 ,     0 , "4  " ,    0 },
  {/*.   16     .*/    17 ,    15 , "CIF" ,    0 },
  {/*.   17     .*/     0 ,    16 , "*  " ,    0 },
  /*                                               вход с символа - 5      */
  {/*.   18     .*/    19 ,     0 , "5  " ,    0 },
  {/*.   19     .*/    20 ,    18 , "CIF" ,    0 },
  {/*.   20     .*/     0 ,    19 , "*  " ,    0 },
  /*                                               вход с символа - 6      */
  {/*.   21     .*/    22 ,     0 , "6  " ,    0 },
  {/*.   22     .*/    23 ,    21 , "CIF" ,    0 },
  {/*.   23     .*/     0 ,    22 , "*  " ,    0 },
  /*                                               вход с символа - 7      */
  {/*.   24     .*/    25 ,     0 , "7  " ,    0 },
  {/*.   25     .*/    26 ,    24 , "CIF" ,    0 },
  {/*.   26     .*/     0 ,    25 , "*  " ,    0 },
  /*                                               вход с символа - 8      */
  {/*.   27     .*/    28 ,     0 , "8  " ,    0 },
  {/*.   28     .*/    29 ,    27 , "CIF" ,    0 },
  {/*.   29     .*/     0 ,    28 , "*  " ,    0 },
  /*                                               вход с символа - 9      */
  {/*.   30     .*/    31 ,     0 , "9  " ,    0 },
  {/*.   31     .*/    32 ,    30 , "CIF" ,    0 },
  {/*.   32     .*/     0 ,    31 , "*  " ,    0 },
  /*                                               вход с символа - A      */
  {/*.   33     .*/    34 ,     0 , "A  " ,    0 },
  {/*.   34     .*/    35 ,    33 , "BUK" ,    0 },
  {/*.   35     .*/     0 ,    34 , "*  " ,    0 },
  /*                                               вход с символа - B      */
  {/*.   36     .*/    37 ,     0 , "B  " ,    0 },
  {/*.   37     .*/    38 ,    36 , "BUK" ,    0 },
  {/*.   38     .*/     0 ,    37 , "*  " ,    0 },
  /*                                               вход с символа - C      */
  {/*.   39     .*/    40 ,     0 , "C  " ,    0 },
  {/*.   40     .*/    41 ,    39 , "BUK" ,    0 },
  {/*.   41     .*/     0 ,    40 , "*  " ,    0 },
  /*                                               вход с символа - D      */
  {/*.   42     .*/    43 ,     0 , "D  " ,    0 },
  {/*.   43     .*/    44 ,    42 , "BUK" ,   45 },
  {/*.   44     .*/     0 ,    43 , "*  " ,    0 },

  {/*.   45     .*/    46 ,    42 , "C  " ,    0 },
  {/*.   46     .*/    47 ,    45 , "L  " ,    0 },
  {/*.   47     .*/    48 ,    46 , "   " ,    0 },
  {/*.   48     .*/    49 ,    47 , "IDE" ,    0 },
  {/*.   49     .*/    50 ,    48 , "   " ,    0 }, /* tomilin: ancestor DEC*/
  {/*.   50     .*/    51 ,    49 , "B  " ,  187 }, /* tomilin: entry point */
  {/*.   51     .*/    52 ,    50 , "I  " ,    0 },
  {/*.   52     .*/    53 ,    51 , "N  " ,    0 },
  {/*.   53     .*/    54 ,    52 , "   " ,    0 },
  {/*.   54     .*/    55 ,    53 , "F  " ,    0 },
  {/*.   55     .*/    56 ,    54 , "I  " ,    0 },
  {/*.   56     .*/    57 ,    55 , "X  " ,    0 },
  {/*.   57     .*/    58 ,    56 , "E  " ,    0 },
  {/*.   58     .*/    59 ,    57 , "D  " ,    0 },
  {/*.   59     .*/    60 ,    58 , "(  " ,    0 },
  {/*.   60     .*/    61 ,    59 , "RZR" ,    0 },
  {/*.   61     .*/    62 ,    60 , ")  " ,    0 },
  {/*.   62     .*/    63 ,    61 , ";  " ,   65 },
  {/*.   63     .*/    64 ,    62 , "ODC" ,    0 },
  {/*.   64     .*/     0 ,    63 , "*  " ,    0 }, /* ?? successor 65?? was65  */

  {/*.   65     .*/    66 ,    61 , "I  " ,    0 }, /* ?? ancestor 61?? ) */
  {/*.   66     .*/    67 ,    65 , "N  " ,    0 },
  {/*.   67     .*/    68 ,    66 , "I  " ,    0 },
  {/*.   68     .*/    69 ,    67 , "T  " ,    0 },
  {/*.   69     .*/    70 ,    68 , "(  " ,    0 },
  {/*.   70     .*/    71 ,    69 , "LIT" ,    0 },
  {/*.   71     .*/    72 ,    70 , ")  " ,    0 },
  {/*.   72     .*/    73 ,    71 , ";  " ,    0 },
  {/*.   73     .*/   186 ,    72 , "ODC" ,    0 },
  /*                                               вход с символа - E      */
  {/*.   74     .*/    75 ,     0 , "E  " ,    0 },
  {/*.   75     .*/    76 ,    74 , "N  " ,   82 },
  {/*.   76     .*/    77 ,    75 , "D  " ,    0 },
  {/*.   77     .*/    78 ,    76 , "   " ,    0 },
  {/*.   78     .*/    79 ,    77 , "IPR" ,    0 },
  {/*.   79     .*/    80 ,    78 , ";  " ,    0 },
  {/*.   80     .*/    81 ,    79 , "OEN" ,    0 },
  {/*.   81     .*/     0 ,    80 , "*  " ,    0 },

  {/*.   82     .*/    83 ,    74 , "BUK" ,    0 },
  {/*.   83     .*/     0 ,    82 , "*  " ,    0 },
  /*                                               вход с символа - M      */
  {/*.   84     .*/    85 ,     0 , "M  " ,    0 },
  {/*.   85     .*/    86 ,    84 , "BUK" ,    0 },
  {/*.   86     .*/     0 ,    85 , "*  " ,    0 },
  /*                                               вход с символа - P      */
  {/*.   87     .*/    88 ,     0 , "P  " ,    0 },
  {/*.   88     .*/    89 ,    87 , "BUK" ,    0 },
  {/*.   89     .*/     0 ,    88 , "*  " ,    0 },
  /*                                               вход с символа - X      */
  {/*.   90     .*/    91 ,     0 , "X  " ,    0 },
  {/*.   91     .*/    92 ,    90 , "BUK" ,    0 },
  {/*.   92     .*/     0 ,    91 , "*  " ,    0 },
  /*                                               вход с символа - BUK    */
  {/*.   93     .*/    94 ,     0 , "BUK" ,    0 },
  {/*.   94     .*/    95 ,    93 , "IDE" ,    0 },
  {/*    95     .*/     0 ,    94 , "*  " ,    0 },
  /*                                               вход с символа - IDE    */
  {/*.   96     .*/    97 ,     0 , "IDE" ,    0 },
  {/*.   97     .*/    98 ,    96 , "BUK" ,  100 },
  {/*.   98     .*/    99 ,    97 , "IDE" ,    0 },
  {/*.   99     .*/     0 ,    98 , "*  " ,    0 },

  {/*.  100     .*/   101 ,    96 , "CIF" ,  103 },
  {/*.  101     .*/   102 ,   100 , "IDE" ,    0 },
  {/*.  102     .*/     0 ,   101 , "*  " ,    0 },

  {/*.  103     .*/   104 ,    96 , "IPE" ,  105 },
  {/*.  104     .*/     0 ,   103 , "*  " ,    0 },

  {/*.  105     .*/   106 ,    96 , "IPR" ,    0 },
  {/*.  106     .*/     0 ,   105 , "*  " ,    0 },
  /*                                               вход с символа - +      */
  {/*.  107     .*/   108 ,     0 , "+  " ,    0 },
  {/*.  108     .*/   109 ,   107 , "ZNK" ,    0 },
  {/*.  109     .*/     0 ,   108 , "*  " ,    0 },
  /*                                               вход с символа - -      */
  {/*.  110     .*/   111 ,     0 , "-  " ,    0 },
  {/*.  111     .*/   112 ,   110 , "ZNK" ,    0 },
  {/*.  112     .*/     0 ,   111 , "*  " ,    0 },
  /*                                               вход с символа - IPR    */
  {/*.  113     .*/   114 ,     0 , "IPR" ,    0 },
  {/*.  114     .*/   115 ,   113 , ":  " ,    0 },
  {/*.  115     .*/   116 ,   114 , "P  " ,    0 },
  {/*.  116     .*/   117 ,   115 , "R  " ,    0 },
  {/*.  117     .*/   118 ,   116 , "O  " ,    0 },
  {/*.  118     .*/   119 ,   117 , "C  " ,    0 },
  {/*.  119     .*/   120 ,   118 , "   " ,    0 },
  {/*.  120     .*/   121 ,   119 , "O  " ,    0 },
  {/*.  121     .*/   122 ,   120 , "P  " ,    0 },
  {/*.  122     .*/   123 ,   121 , "T  " ,    0 },
  {/*.  123     .*/   124 ,   122 , "I  " ,    0 },
  {/*.  124     .*/   125 ,   123 , "O  " ,    0 },
  {/*.  125     .*/   126 ,   124 , "N  " ,    0 },
  {/*.  126     .*/   127 ,   125 , "S  " ,    0 },
  {/*.  127     .*/   128 ,   126 , "(  " ,    0 },
  {/*.  128     .*/   129 ,   127 , "M  " ,    0 },
  {/*.  129     .*/   130 ,   128 , "A  " ,    0 },
  {/*.  130     .*/   131 ,   129 , "I  " ,    0 },
  {/*.  131     .*/   132 ,   130 , "N  " ,    0 },
  {/*.  132     .*/   133 ,   131 , ")  " ,    0 },
  {/*.  133     .*/   134 ,   132 , ";  " ,    0 },
  {/*.  134     .*/   135 ,   133 , "OPR" ,    0 },
  {/*.  135     .*/     0 ,   134 , "*  " ,    0 },
  /*                                                вход с символа - CIF    */
  {/*.  136     .*/   137 ,     0 , "CIF" ,    0 },
  {/*.  137     .*/   138 ,   136 , "RZR" ,  234 }, /* tomilin: entry point */ /*Li: must be 234*/
  {/*.  138     .*/     0 ,   137 , "*  " ,    0 }, /* ancestor was 0 */
  /*                                               вход с символа - RZR    */
  {/*.  139     .*/   140 ,     0 , "RZR" ,    0 },
  {/*.  140     .*/   141 ,   139 , "CIF" ,    0 },
  {/*.  141     .*/   142 ,   140 , "RZR" ,    0 },
  {/*.  142     .*/     0 ,   141 , "*  " ,    0 },
  /*                                               вход с символа - MAN    */
  {/*.  143     .*/   144 ,     0 , "MAN" ,    0 },
  {/*.  144     .*/   145 ,   143 , "B  " ,  147 },
  {/*.  145     .*/   146 ,   144 , "LIT" ,    0 },
  {/*.  146     .*/     0 ,   145 , "*  " ,    0 },

  {/*.  147     .*/   148 ,   143 , "0  " ,  150 },
  {/*.  148     .*/   149 ,   147 , "MAN" ,    0 },
  {/*.  149     .*/     0 ,   148 , "*  " ,    0 },

  {/*.  150     .*/   151 ,   143 , "1  " ,    0 },
  {/*.  151     .*/   152 ,   150 , "MAN" ,    0 },
  {/*.  152     .*/     0 ,   151 , "*  " ,    0 },
  /*                                               вход с символа - IPE    */
  {/*.  153     .*/   154 ,     0 , "IPE" ,    0 },
  {/*.  154     .*/   155 ,   153 , "=  " ,  159 },
  {/*.  155     .*/   156 ,   154 , "AVI" ,    0 },
  {/*.  156     .*/   157 ,   155 , ";  " ,    0 },
  {/*.  157     .*/   158 ,   156 , "OPA" ,    0 },
  {/*.  158     .*/     0 ,   157 , "*  " ,    0 },

  {/*.  159     .*/   160 ,   153 , "AVI" ,    0 },
  {/*.  160     .*/     0 ,   159 , "*  " ,    0 },
  /*                                               вход с символа - LIT    */
  {/*.  161     .*/   162 ,     0 , "LIT" ,    0 },
  {/*.  162     .*/   163 ,   161 , "AVI" ,    0 },
  {/*.  163     .*/     0 ,   162 , "*  " ,    0 },
  /*.                                              вход с символа - AVI    */
  {/*.  164     .*/   165 ,     0 , "AVI" ,    0 },
  {/*.  165     .*/   166 ,   164 , "ZNK" ,    0 },
  {/*.  166     .*/   167 ,   165 , "LIT" ,  168 },
  {/*.  167     .*/   197 ,   166 , "AVI" ,    0 },

  {/*.  168     .*/   169 ,   165 , "IPE" ,    0 },
  {/*.  169     .*/   170 ,   168 , "AVI" ,    0 },
  {/*.  170     .*/     0 ,   169 , "*  " ,    0 },
  /*                                               вход с символа - OPR    */
  {/*.  171     .*/   172 ,     0 , "OPR" ,    0 },
  {/*.  172     .*/   173 ,   171 , "TEL" ,    0 },
  {/*.  173     .*/   174 ,   172 , "OEN" ,    0 },
  {/*.  174     .*/   175 ,   173 , "PRO" ,    0 },
  {/*.  175     .*/     0 ,   174 , "*  " ,    0 },
  /*.                                              вход с символа - ODC    */
  {/*.  176     .*/   177 ,     0 , "ODC" ,    0 },
  {/*.  177     .*/   178 ,   176 , "TEL" ,    0 },
  {/*.  178     .*/     0 ,   177 , "*  " ,    0 },
  /*.                                              вход с символа - TEL    */
  {/*.  179     .*/   180 ,     0 , "TEL" ,    0 },
  {/*.  180     .*/   181 ,   179 , "ODC" ,  183 },
  {/*.  181     .*/   182 ,   180 , "TEL" ,    0 },
  {/*.  182     .*/     0 ,   181 , "*  " ,    0 },

  {/*.  183     .*/   184 ,   179 , "OPA" ,    0 },
  {/*.  184     .*/   185 ,   183 , "TEL" ,    0 },
  {/*.  185     .*/     0 ,   184 , "*  " ,    0 },

  {/*.  186     .*/     0 ,    73 , "*  " ,    0 },

  {/*.  187     .*/   188 ,    49 , "C  " ,  201 }, /* tomilin: entry point */
  {/*.  188     .*/   189 ,   187 , "H  " ,    0 },
  {/*.  189     .*/   190 ,   188 , "A  " ,    0 },
  {/*.  190     .*/   191 ,   189 , "R  " ,    0 },
  {/*.  191     .*/   192 ,   190 , "(  " ,    0 },
  {/*.  192     .*/   193 ,   191 , "RZR" ,    0 },
  {/*.  193     .*/   194 ,   192 , ")  " ,    0 },
  {/*.  194     .*/   195 ,   193 , ";  " ,    0 },
  {/*.  195     .*/   196 ,   194 , "ODC" ,    0 },
  {/*.  196     .*/     0 ,   195 , "*  " ,    0 },

  {/*.  197     .*/     0 ,   167 , "*  " ,    0 },

  {/*.  198     .*/   199 ,     0 , "*  " ,    0 },
  {/*.  199     .*/   200 ,   198 , "ZNK" ,    0 },
  {/*.  200     .*/     0 ,   199 , "*  " ,    0 },

  {/*.  201     .*/   202 ,    49 , "D  " ,  221 }, /* tomilin: DEC_FIXED... */
  {/*.  202     .*/   203 ,   201 , "E  " ,    0 },
  {/*.  203     .*/   204 ,   202 , "C  " ,    0 },
  {/*.  204     .*/   205 ,   203 , "   " ,    0 },
  {/*.  205     .*/   206 ,   204 , "F  " ,    0 },
  {/*.  206     .*/   207 ,   205 , "I  " ,    0 },
  {/*.  207     .*/   208 ,   206 , "X  " ,    0 },
  {/*.  208     .*/   209 ,   207 , "E  " ,    0 },
  {/*.  209     .*/   210 ,   208 , "D  " ,    0 },
  {/*.  210     .*/   211 ,   209 , "   " ,    0 },
  {/*.  211     .*/   212 ,   210 , "I  " ,    0 },
  {/*.  212     .*/   213 ,   211 , "N  " ,    0 },
  {/*.  213     .*/   214 ,   212 , "I  " ,    0 },
  {/*.  214     .*/   215 ,   213 , "T  " ,    0 },
  {/*.  215     .*/   216 ,   214 , "(  " ,    0 },
  {/*.  216     .*/   217 ,   215 , "DCF" ,    0 },
  {/*.  217     .*/   218 ,   216 , ")  " ,    0 },
  {/*.  218     .*/   219 ,   217 , ";  " ,    0 },
  {/*.  219     .*/   220 ,   218 , "ODC" ,    0 },
  {/*.  220     .*/     0 ,   219 , "*  " ,    0 },

  {/*.  221     .*/   222 ,    49 , "B  " ,    0 }, /* tomilin: BIT(INIT... */
  {/*.  222     .*/   223 ,   221 , "I  " ,    0 },
  {/*.  223     .*/   224 ,   222 , "T  " ,    0 },
  {/*.  224     .*/   225 ,   223 , "(  " ,    0 },
  {/*.  225     .*/   226 ,   224 , "RZR" ,    0 },
  {/*.  226     .*/   227 ,   225 , ")  " ,    0 },
  {/*.  227     .*/   228 ,   226 , ";  " ,    0 },
  {/*.  228     .*/   229 ,   227 , "ODC" ,    0 },
  {/*.  229     .*/     0 ,   228 , "*  " ,    0 },

  {/*.  230     .*/   231 ,     0 , "DCF" ,    0 }, /* tomilin: DEC_FIXED... */
  {/*.  231     .*/   232 ,   230 , "CIF" ,    0 },
  {/*.  232     .*/   233 ,   231 , "DCF" ,    0 },
  {/*.  233     .*/     0 ,   232 , "*  " ,    0 },

  {/*.  234     .*/   235 ,   136 , "DCF" ,  231 }, /* tomilin: DEC_FIXED... */ /* Li: alt was 0*/
  {/*.  235     .*/     0 ,   234 , "*  " ,    0 } 
};


/*
***** Таблица  входов в "кусты" ( корней )грамматических правил,
***** содержащая тип ( терминальность или нетерминальность ) корневых
***** символов
*/

struct
{
  char SYM[4];
  int  VX;
  char TYP;
} VXOD[NVXOD] =
/*   __________ ___________ _____ ______
    |  NN      |    символ | вход| тип  |
    |__________|___________|_____|______|                                  */

{
  {/*.   1     .*/   "AVI" , 164 , 'N' },
  {/*.   2     .*/   "BUK" ,  93 , 'N' },
  {/*.   3     .*/   "CIF" , 136 , 'N' },
  {/*.   4     .*/   "IDE" ,  96 , 'N' },
  {/*.   5     .*/   "IPE" , 153 , 'N' },
  {/*.   6     .*/   "IPR" , 113 , 'N' },
  {/*.   7     .*/   "LIT" , 161 , 'N' },
  {/*.   8     .*/   "MAN" , 143 , 'N' },
  {/*.   9     .*/   "ODC" , 176 , 'N' },
  {/*.  10     .*/   "OEN" ,   0 , 'N' },
  {/*.  11     .*/   "OPA" ,   0 , 'N' },
  {/*.  12     .*/   "OPR" , 171 , 'N' },
  {/*.  13     .*/   "PRO" ,   0 , 'N' },
  {/*.  14     .*/   "RZR" , 139 , 'N' },
  {/*.  15     .*/   "TEL" , 179 , 'N' },
  {/*.  16     .*/   "ZNK" ,   0 , 'N' },
  {/*.  17     .*/   "DCF" , 234 , 'N' }, // was 234
  {/*.  18     .*/   "A  " ,  33 , 'T' },
  {/*.  19     .*/   "B  " ,  36 , 'T' },
  {/*.  20     .*/   "C  " ,  39 , 'T' },
  {/*.  21     .*/   "D  " ,  42 , 'T' },
  {/*.  22     .*/   "E  " ,  74 , 'T' },
  {/*.  23     .*/   "M  " ,  84 , 'T' },
  {/*.  24     .*/   "P  " ,  87 , 'T' },
  {/*.  25     .*/   "X  " ,  90 , 'T' },
  {/*.  26     .*/   "0  " ,   1 , 'T' },
  {/*.  27     .*/   "1  " ,   4 , 'T' },
  {/*.  28     .*/   "2  " ,   9 , 'T' },
  {/*.  29     .*/   "3  " ,  12 , 'T' },
  {/*.  30     .*/   "4  " ,  15 , 'T' },
  {/*.  31     .*/   "5  " ,  18 , 'T' },
  {/*.  32     .*/   "6  " ,  21 , 'T' },
  {/*.  33     .*/   "7  " ,  24 , 'T' },
  {/*.  34     .*/   "8  " ,  27 , 'T' },
  {/*.  35     .*/   "9  " ,  30 , 'T' },
  {/*.  36     .*/   "+  " , 107 , 'T' },
  {/*.  37     .*/   "-  " , 110 , 'T' },
  {/*.  38     .*/   ":  " ,   0 , 'T' },
  {/*.  39     .*/   "I  " ,   0 , 'T' },
  {/*.  40     .*/   "R  " ,   0 , 'T' },
  {/*.  41     .*/   "N  " ,   0 , 'T' },
  {/*.  42     .*/   "O  " ,   0 , 'T' },
  {/*.  43     .*/   "T  " ,   0 , 'T' },
  {/*.  44     .*/   "S  " ,   0 , 'T' },
  {/*.  45     .*/   "(  " ,   0 , 'T' },
  {/*.  46     .*/   ")  " ,   0 , 'T' },
  {/*.  47     .*/   "   " ,   0 , 'T' },
  {/*.  48     .*/   ";  " ,   0 , 'T' },
  {/*.  49     .*/   "L  " ,   0 , 'T' },
  {/*.  50     .*/   "F  " ,   0 , 'T' },
  {/*.  51     .*/   "=  " ,   0 , 'T' },
  {/*.  52     .*/   "H  " ,   0 , 'T' },
  {/*.  53     .*/   "*  " , 198 , 'T' }
};


/*
***** Т а б л и ц а  матрицы смежности - основа построения матрицы
***** преемников
*/
char TPR[NVXOD][NNETRM] =
{
  /*
     __________ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___
    |       AVI:BUK:CIF:IDE:IPE:IPR:LIT:MAN:ODC:OEN:OPA:OPR:PRO:RZR:TEL:ZNK:DCF|
    |__________:___:___:___:___:___:___:___:___:___:___:___:___:___:___:___:___| */
    {/*AVI*/ 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 },
    {/*BUK*/ 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 },
    {/*CIF*/ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 1 },
    {/*IDE*/ 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 },
    {/*IPE*/ 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 },
    {/*IPR*/ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 },
    {/*LIT*/ 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 },
    {/*MAN*/ 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 },
    {/*ODC*/ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 },
    {/*OEN*/ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 },
    {/*OPA*/ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 },
    {/*OPR*/ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 },
    {/*PRO*/ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 },
    {/*RZR*/ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 },
    {/*TEL*/ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 },
    {/*ZNK*/ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 },
    {/*DCF*/ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 },
    /*
       __________ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___
      |       AVI:BUK:CIF:IDE:IPE:IPR:LIT:MAN:ODC:OEN:OPA:OPR:PRO:RZR:TEL:ZNK:DCF|
      |__________:___:___:___:___:___:___:___:___:___:___:___:___:___:___:___:___| */
      {/*  A*/ 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 },
      {/*  B*/ 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 },
      {/*  C*/ 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 },
      {/*  D*/ 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 },
      {/*  E*/ 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 },
      {/*  M*/ 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 },
      {/*  P*/ 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 },
      {/*  X*/ 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 },
      {/*  0*/ 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 },
      {/*  1*/ 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 },
      {/*  2*/ 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 },
      {/*  3*/ 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 },
      {/*  4*/ 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 },
      {/*  5*/ 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 },
      {/*  6*/ 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 },
      {/*  7*/ 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 },
      /*
         __________ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___
        |       AVI:BUK:CIF:IDE;IPE:IPR:LIT:MAN:ODC:OEN:OPA:OPR:PRO:RZR:TEL:ZNK:DCF|
        |__________:___:___:___:___:___:___:___:___:___:___:___:___:___:___:___:___| */
        {/*  8*/ 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 },
        {/*  9*/ 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 },
        {/*  +*/ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 },
        {/*  -*/ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 },
        {/*  :*/ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 },
        {/*  I*/ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 },
        {/*  R*/ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 },
        {/*  N*/ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 },
        {/*  O*/ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 },
        {/*  T*/ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 },
        {/*  S*/ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 },
        {/*  (*/ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 },
        {/*  )*/ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 },
        {/*  ;*/ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 },
        {/*   */ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 },
        {/*  L*/ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 },
        /*
          __________ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___
        |       AVI:BUK:CIF:IDE:IPE:IPR:LIT:MAN:ODC:OEN;OPA:OPR:PR0:RZR:TEL:ZNK:DCF|
        |__________:___:___:___:___:___:___:___:___:___:___:___:___:___:___:___:___| */
        {/*  F*/ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0, 0 },
        {/*  =*/ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0, 0 },
        {/*  H*/ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0, 0 },
        {/*  **/ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1, 0 }
        /*|__________________________________________________________________________| */
};




/*..........................................................................*/

struct              /* таблица имен меток и   */
{                  /* переменных, заполняемая*/
  char NAME[8];    /* на первом проходе се-  */
  char TYPE;        /* мантического вычисления*/
  char RAZR[5];    /* и используемая на вто- */
  char INIT[50];   /* ром проходе семантического вычисления*/
} SYM[NSYM];

int ISYM = 0;       /* текущий индекс таблицы имен*/

char NFIL[30] = "\x0";   /* хранилище имени транслируемой программы     */




/*..........................................................................*/

char* getDateTime()
{
  static char nowtime[20];
  time_t rawtime;
  struct tm* ltime;
  time(&rawtime);
  ltime = localtime(&rawtime);
  strftime(nowtime, 20, "%Y-%m-%d %H:%M:%S", ltime);
  return nowtime;
}

void print_title_log() {
  char* nowtime = getDateTime();
  fprintf(fp_out, "\n\n\n\n\n\n PROGRAM START...\n//////////////////////////////////////////////////////////////////////\n");
  fprintf(fp_out, "////////////////////////////////////////// %s ///////\n", nowtime);
  fprintf(fp_out, "//////////////////////////////////////////////////////////////////////\n\n");
  fflush(fp_out);
}


void print_ASSTXT_to_file() {
  fprintf(fp_out, "\n%s \n", "SYNTAX ANALYZE FINISHED! NOW PRINTING IASSTXT... ");
  fprintf(fp_out, "%s = %d\n", "IASSTXT(lines)", IASSTXT);
  fprintf(fp_out, "%s\n", "--------- ASS ---------> \n");
  for (int i = 0; i < IASSTXT; i++) {
    fprintf(fp_out, "%d\t%s\n", i, ASSTXT[i]);
  }
  fprintf(fp_out, "\n%s\n", "<------------ASS ------\n");
  fflush(fp_out);
}

void print_DST() {
  fprintf(fp_out, "%s\n", "---> print DST stack:");
  for (int i = 0; i < L; i++) {

    int tmp = 0;
    tmp = idx_of_VXOD(DST[i].DST1, 3);
    fprintf(fp_out,
      ">>(%d/%d)\t\t%s\t\t%d\t\t%d\t\t%d\t\t%d\n",
      i, L,
      DST[i].DST1,
      DST[i].DST2,
      DST[i].DST3,
      DST[i].DST4,
      DST[i].DST5);
  }
  fprintf(fp_out, "%s\n\n", "<----");
  fflush(fp_out);
}

void print_error_message_of_COD(int result_gen_COD) {
  switch (result_gen_COD)                         /* семантическое вычислен.*/
  {  
  case  1:                                    /*если код завершения = 1,*/
    printf("%s\n",                           /* - диагностич.сообщение;*/
      "Name of product doesn't fix.");
    break;                                     /* - выйти на обобщающую  *//* - диагностич.сообщение; диагностику             */
  case  2:                                    /*если код завершения = 2,*/
    /* то:                    */
    STROKA[DST[I2].DST2 + 20] = '\x0';      /* - диагностич.сообщение;*/
    printf("%s%s\n%s%s%s\n",
      "Type of identifier not allow: ",
      &FORMT[1], " в исх.тексте -> \"...",
      &STROKA[DST[I2].DST2], "...\"");
    break;                                     /* - выйти на обобщающую диагностику             */
  case  3:                                    /*если код завершения = 3,*/
    /* то:                    */
    STROKA[DST[I2].DST2 + 20] = '\x0';     /* - диагностич.сообщение;*/
    printf("%s%s\n%s%s%s\n",
      "Type of identifier not allow_2",
      &FORMT[IFORMT - 1], " в исх.тексте -> \"...",
      &STROKA[DST[I2].DST2], "...\"");
    break;                                     /* -выйти на обобщающую  диагностику */
  case  4:                                    /*если код завершения = 4,*/
    /* то:                    */
    STROKA[DST[I2].DST2 + 20] = '\x0';     /* - диагностич.сообщение;*/
    printf("%s%s\n%s%s%s\n",
      "Undefined identifier: ",
      &FORMT[IFORMT - 1], " в исх.тексте -> \"...",
      &STROKA[DST[I2].DST2], "...\"");
    break;                                     /* - выйти на обобщающую диагностику */
  case  5:                                    /*если код завершения = 5,*/
    STROKA[DST[I2].DST2 + 20] = '\x0';     /* - диагностич.сообщение;*/
    printf("%s%c\n%s%s%s\n",
      "Undefined operation: ",
      STROKA[DST[I2].DST4 - strlen(FORMT[IFORMT - 1])],
      " ERROR HERE -> \"...", &STROKA[DST[I2].DST2], "...\"");
    break;                                     /* - выйти на обобщающую диагностику */
  case  6:                                    /*если код завершения = 6 */
    STROKA[DST[I2].DST2 + 20] = '\x0';     /* - диагностич.сообщение;*/
    printf("%s%s\n%s%s%s\n",
      "Identifier re-declared: ",
      &FORMT[1], " ERROR HERE -> \"...",
      &STROKA[DST[I2].DST2], "...\"");
    break;                                     /* - выйти на обобщающую диагностику */
  }
}

void print_error_code(int return_code) {
  STROKA[I4 + 20] = '\x0';
  fprintf(fp_out, "[ERROR] CODE: %d\n", return_code);
  fprintf(fp_out, "%s%s%s%s\n", "[ERROR INFO] Syntax error here-> ", "\"...", &STROKA[I4], "...\"");
  printf("%s\n", "ERROR.");
}


/*..........................................................................*/

void compress_ISXTXT()
{
  fprintf(fp_out, "---> %s\n", "void compress_ISXTXT()");
  fflush(fp_out);

  I3 = 0;
  for (I1 = 0; I1 < NISXTXT; I1++)
  {
    for (I2 = 0; I2 < 80; I2++)
      if (ISXTXT[I1][I2] != '\x0')
      {
        if (ISXTXT[I1][I2] == ' ' && /* 分隔符 */
          (PREDSYM == ' ' || PREDSYM == ';' ||
            PREDSYM == ')' || PREDSYM == ':' ||
            PREDSYM == '('
            )
          )
        {
          PREDSYM = ISXTXT[I1][I2];
          goto L2;
        }

        if
          (
            (ISXTXT[I1][I2] == '+' ||
              ISXTXT[I1][I2] == '-' ||
              ISXTXT[I1][I2] == '=' ||
              ISXTXT[I1][I2] == '(' ||
              ISXTXT[I1][I2] == ')' ||
              ISXTXT[I1][I2] == '*'
              )
            &&
            PREDSYM == ' '
            )
        {
          I3--;
          goto L1;
        }


        if (ISXTXT[I1][I2] == ' ' &&
          (PREDSYM == '+' || PREDSYM == '-' ||
            PREDSYM == '=' || PREDSYM == '*'
            )
          )
        {
          goto L2;
        }

      L1:
        PREDSYM = ISXTXT[I1][I2];
        STROKA[I3] = PREDSYM;
        I3++;

      L2:    continue;
      }
      else
        break;
  }
  STROKA[I3] = '\x0';

  fprintf(fp_out, "Text after compress:\n%s\n\n", STROKA);
  fflush(fp_out);

}

/*..........................................................................*/


void build_TPR()
{
  fprintf(fp_out, "---> %s\n", "void build_TPR()");
  fflush(fp_out);

  for (I1 = 0; I1 < NNETRM; I1++)
  {
    for (I2 = 0; I2 < NVXOD; I2++)
    {
      if (TPR[I2][I1] & (I1 != I2))
      {
        for (I3 = 0; I3 < NNETRM; I3++)
          TPR[I2][I3] |= TPR[I1][I3];
      }
    }
  }
}

/*..........................................................................*/

void mcel(const char* T1, int T2, int T3)
{
  strcpy(CEL[K].CEL1, T1);
  CEL[K].CEL2 = T2;
  CEL[K].CEL3 = T3;
  K++;
}

/*..........................................................................*/

void mdst(char* T1, int T2, int T3, int T4, int T5)
{
  strcpy(DST[L].DST1, T1);
  DST[L].DST2 = T2;
  DST[L].DST3 = T3;
  DST[L].DST4 = T4;
  DST[L].DST5 = T5;
  L++;
}



/*..........................................................................*/
              /* п р о г р а м м а      */
int idx_of_VXOD(const char* T1, int T2)
/* 主要作用是在一个名为 VXOD 的表格中查找与给定字符串 T1 完全匹配的条目，并返回该条目的索引 */
{
  int k;

  for (I1 = 0; I1 < NVXOD; I1++)
  {
    for (k = 0; k < T2; k++)
    {
      if ((*(T1 + k) != VXOD[I1].SYM[k]))
        goto numb1;
    }
    if ((VXOD[I1].SYM[k] == '\x0') || (VXOD[I1].SYM[k] == ' '))
      return (I1);
  numb1:
    continue;
  }
  return -1;
}

/*..........................................................................*/

int sint_ANAL() 
{               
  fprintf(fp_out, "---> %s\n", "int sint_ANAL()");
  fflush(fp_out);

  I4 = 0;
  /* 初始化（начальных установок）*/
L1:

  K = 0;
  L = 0;
  I = 0;
  J = 1;
  mcel("PRO", I, 999);

  if (!TPR[idx_of_VXOD(&STROKA[I], 1)][idx_of_VXOD("PRO", 3)])
    return 1;
  /*根据所选假设对非终结符进行投影(проецирования нетерминала по выбранной гипотезе )*/
L2: /*Вход в граф */

  J = VXOD[idx_of_VXOD(&STROKA[I], 1)].VX;

L3: /* Проверка терм. 1 */

  J = SINT[J].POSL;

L31:

  I++; //? J++?

  if (I > I4)
    I4 = I;

  if (VXOD[idx_of_VXOD(SINT[J].DER, 3)].TYP == 'T')
  {
    if (STROKA[I] == SINT[J].DER[0])
      goto L3;
    else
      goto L8;
  }
  /* Блок обработки нетерминалов */
L4:
  if (SINT[SINT[J].POSL].DER[0] == '*') // 已结束？
  {
    I--;

    if (!strcmp(SINT[J].DER, CEL[K - 1].CEL1))
    { // Блок обработки нетерминалов (продолжение)
      mdst(CEL[K - 1].CEL1, CEL[K - 1].CEL2, CEL[K - 1].CEL3, I, J);
      if (!strcmp(CEL[K - 1].CEL1, "PRO"))
        return 0; // 成功返回
    L5:
      if (TPR[idx_of_VXOD(CEL[K - 1].CEL1, 3)][idx_of_VXOD(CEL[K - 1].CEL1, 3)]) {
        J = VXOD[idx_of_VXOD(CEL[K - 1].CEL1, 3)].VX;
        goto L3;
      }

    L6:
      J = CEL[K - 1].CEL3;
      K--;
      goto L3;
    }

    if (!TPR[idx_of_VXOD(SINT[J].DER, 3)][idx_of_VXOD(CEL[K - 1].CEL1, 3)])
      goto L9; // Обратный поиск 2

    mdst(SINT[J].DER, CEL[K - 1].CEL2, 0, I, J);
    J = VXOD[idx_of_VXOD(SINT[J].DER, 3)].VX;
    goto L3;
  }

  if (!TPR[idx_of_VXOD(&STROKA[I], 1)][idx_of_VXOD(SINT[J].DER, 3)])
    goto L8;

  mcel(SINT[J].DER, I, J);
  goto L2;

L8: /*Проверка терм. 1 */

  I--;

L9: /* Обратный поиск 2 */

  if (SINT[J].ALT != 0)
  {
    J = SINT[J].ALT;
    goto L31;
  }

  J = SINT[J].PRED;

  if ((VXOD[idx_of_VXOD(SINT[J].DER, 3)].TYP == 'N')
    && (SINT[J].PRED > 0))
  {
    mcel(DST[L - 1].DST1, DST[L - 1].DST2, DST[L - 1].DST3);

  L10: /* Блок перебора гипотез (продолжение 1) */

    J = DST[L - 1].DST5;
    L--;
    goto L9;
  }

  if ((VXOD[idx_of_VXOD(SINT[J].DER, 3)].TYP == 'N')
    && (SINT[J].PRED == 0))
  {
    if (!strcmp(CEL[K - 1].CEL1, DST[L - 1].DST1))
      goto L6;
    else
      goto L10;
  }

  if (SINT[J].PRED > 0)
    goto L8;

  J = CEL[K - 1].CEL3;
  K--;

  if (J == 999)
    return 2; // 错误
  else
    goto L8; // Блок перебора гипотез продолжение 2)
}

long int VALUE(char* s)                        /* п р о г р а м м а      */
{                                                /* перевода двоичной      */
  long int S;                                     /* константы из ASCIIz-ви-*/
  int i;                                          /* да во внутреннее представление типа long int */

  i = 0;
  S = 0;
  while (*(s + i) != 'B')

  {

    S <<= 1;
    if (*(s + i) == '1')
      S++;
    i++;
  }

  return (S);
}



/*..........................................................................*/
void FORM()                                      /* п р о г р а м м а      */
{                                                /* представления фрагмента*/
             /* плотного текста в виде */
             /* массива 9-ти символьных*/
             /* лексем                 */
  int i, j;

  for (IFORMT = 0; IFORMT < MAXFORMT; IFORMT++)
    memcpy(FORMT[IFORMT], "\x0\x0\x0\x0\x0\x0\x0\x0\x0", 9);

  IFORMT = 0;
  j = DST[I2].DST2;

FORM1:

  for (i = j; i <= DST[I2].DST4 + 1; i++)
  {
    if (STROKA[i] == ':' || STROKA[i] == ' ' ||
      STROKA[i] == '(' || STROKA[i] == ')' ||
      STROKA[i] == ';' || STROKA[i] == '+' ||
      STROKA[i] == '-' || STROKA[i] == '=' ||
      STROKA[i] == '*'
      )
    {
      FORMT[IFORMT][i - j] = '\x0';
      IFORMT++;
      j = i + 1;
      goto FORM1;
    }
    else
      FORMT[IFORMT][i - j] = STROKA[i];

  }

  return;
}



/*..........................................................................*/
/* 从 ASS_CARD 拷贝到 ASSTXT 中 */
              /* п р о г р а м м а      */
void ZKARD() /* записи очередной сгене-*/
{            /* рированной записи вы-  */
             /* ходного файла в массив */
             /* ASSTXT                 */
  fprintf(fp_out, "%s\n", "---> void ZKARD()");
  fprintf(fp_out, "%s = %d\n", "IASSTXT", IASSTXT);
  fprintf(fp_out, "%s = %s <--- \n", "ASS_CARD.BUFCARD", ASS_CARD.BUFCARD);
  fflush(fp_out);

  char i;
  memcpy(ASSTXT[IASSTXT++], ASS_CARD.BUFCARD, 80);

  for (i = 0; i < 79; i++)
    ASS_CARD.BUFCARD[i] = ' ';
  return;
}



/* Li      */
/* функция для записи сформированных строк в массив ASSTXT */
void ZKARD2(const char* label, const char* directive, 
  const char* operand, const char* comment) 
{
  char buffer[80]; // Предположим, что максимальная длина строки - 80 символов
  // Форматируем строку согласно заданному шаблону
  if (strlen(operand) > 0) 
  {
    snprintf(buffer, sizeof(buffer), "%s        %s    %s  %s", label, directive, operand, comment);
  }
  else 
  {
    snprintf(buffer, sizeof(buffer), " %s        %s     %s", label, directive, comment);
  }

  // Печать для отладки, можно убрать в финальной версии
  //printf("Writing to ASSTXT[%d]: %s\n", IASSTXT, buffer);

  // Копирование сформированной строки в массив ASSTXT и инкремент индекса
  memcpy(ASSTXT[IASSTXT++], buffer, strlen(buffer) + 1); // +1 для терминирующего нуля

  // Очистка буфера (необязательно, зависит от требований к безопасности)
  memset(buffer, 0, sizeof(buffer));
}


/* ///////////////////////////////////////////////////////////////// */


/*..........................................................................*/
              /* п р о г р а м м а      */
              /* семантич. вычисления   */
              /* нетерминала AVI на пер-*/
              /* вом проходе.   Здесь   */
              /* AVI -   "арифм.выраж." */
int AVI1()
{
  //fprintf(fp_out, "%s\n", "AVI1");
  //fflush(fp_out);

  return 0;
}

/*..........................................................................*/

              /* п р о г р а м м а      */
              /* семантич. вычисления   */
              /* нетерминала BUK на пер-*/
              /* вом проходе.   Здесь   */
              /* BUK -   "буква"        */
int BUK1()
{
  //fprintf(fp_out, "%s\n", "BUK1");
  //fflush(fp_out);

  return 0;
}

/*..........................................................................*/

              /* п р о г р а м м а      */
              /* семантич. вычисления   */
              /* нетерминала CIF на пер-*/
              /* вом проходе.   Здесь   */
              /* CIF -   "цифра"        */
int CIF1()
{
  //fprintf(fp_out, "%s\n", "CIF1");
  //fflush(fp_out);

  return 0;
}

/*..........................................................................*/

              /* п р о г р а м м а      */
              /* семантич. вычисления   */
              /* нетерминала IDE на пер-*/
              /* вом проходе.   Здесь   */
              /* IDE -   "идентификатор"*/
int IDE1()
{
  //fprintf(fp_out, "%s\n", "IDE1");
  //fflush(fp_out);

  return 0;
}

/*..........................................................................*/

              /* п р о г р а м м а      */
              /* семантич. вычисления   */
              /* нетерминала IPE на пер-*/
              /* вом проходе.   Здесь   */
              /* IPE - "имя переменной" */
int IPE1()
{
  //fprintf(fp_out, "%s\n", "IPE1");
  //fflush(fp_out);

  return 0;
}

/*..........................................................................*/

              /* п р о г р а м м а      */
              /* семантич. вычисления   */
              /* нетерминала IPR на пер-*/
              /* вом проходе.   Здесь   */
              /* IPR -   "имя программы" */
int IPR1()
{
  //fprintf(fp_out, "%s\n", "IPR1");
  //fflush(fp_out);

  return 0;
}

/*..........................................................................*/

              /* п р о г р а м м а      */
              /* семантич. вычисления   */
              /* нетерминала LIT на пер-*/
              /* вом проходе.   Здесь   */
              /* LIT -   "литерал"      */
int LIT1()
{
  //fprintf(fp_out, "%s\n", "LIT1");
  //fflush(fp_out);

  return 0;
}

/*..........................................................................*/

              /* п р о г р а м м а      */
              /* семантич. вычисления   */
              /* нетерминала MAN на пер-*/
              /* вом проходе.   Здесь   */
              /* MAN -   "мантисса"     */
int MAN1()
{
  //fprintf(fp_out, "%s\n", "MAN1");
  //fflush(fp_out);

  return 0;
}

/*..........................................................................*/

              /* п р о г р а м м а      */
              /* семантич. вычисления   */
              /* нетерминала ODC на пер-*/
              /* вом проходе.   Здесь   */
              /* ODC - "операт.ПЛ1- DCL"*/
int ODC1()
{
  //fprintf(fp_out, "%s\n", "ODC1");
  //fflush(fp_out);

  int i;
  FORM();                                   /* форматирование ПЛ1-оператора DCL*/

  for (i = 0; i < ISYM; i++)                    /* если фиксируем повтор- */
  {                                              /* повторное объявление   */
    if (!strcmp(SYM[i].NAME, FORMT[1]) &&  /* второго терма оператора*/
      strlen(SYM[i].NAME) ==              /* DCL, то                */
      strlen(FORMT[1])
      )
      return 6;                                    /* завершение программы   */
    /* по ошибке              */
  }

  strcpy(SYM[ISYM].NAME, FORMT[1]);          /* при отсутствии повтор- */
  strcpy(SYM[ISYM].RAZR, FORMT[4]);          /* ного объявления иденти-*/
  /* фикатора запоминаем его*/
  /* вместе с разрядностью в*/
  /* табл.SYM               */
  
  /* если идентификатор определен как bin fixed, */
  if (!strcmp(FORMT[2], "BIN") && !strcmp(FORMT[3], "FIXED"))
  {
    SYM[ISYM].TYPE = 'B';                        /* то устанавливаем тип   */
    /* идентификатора = 'B' и */
    goto ODC11;                                   /* идем на продолжение об-*/
    /* работки, а             */
  }
  /* DCL A DEC FIXED INIT (5); */
  else if (!strcmp(FORMT[2], "DEC") && !strcmp(FORMT[3], "FIXED")) // Li
  {
    SYM[ISYM].TYPE = 'D';   
    if (!strcmp(FORMT[4], "INIT")) // Li
    {
      strcpy(SYM[ISYM++].INIT, FORMT[5]);
    }
  }
  /* DCL B BIT(16); */
  else if (!strcmp(FORMT[2], "BIT"))
  {
    SYM[ISYM].TYPE = 'b';
  }
  else                                            /* иначе                  */
  {
    SYM[ISYM].TYPE = 'U';                        /* устанавливаем тип иден-*/
    /* тификатора = 'U'  и    */
    return 2;                                     /* завершаем программу    */
    /* по ошибке              */
  }

ODC11:                                            /* если идентификатор     */
  /* имеет начальную иници- */
  if (!strcmp(FORMT[5], "INIT"))           /* ализацию, то запомина- */
    strcpy(SYM[ISYM++].INIT, FORMT[6]);       /* ем в табл. SYM это на- */
  /* чальное значение, а    */
  else                                            /* иначе                  */
    strcpy(SYM[ISYM++].INIT, "0B");            /* инициализируем иденти- */
  /* фикатор нулем          */

  return 0;                                      /* успешное завешение     */
  /* программы              */
}

/*..........................................................................*/

              /* п р о г р а м м а      */
              /* семантич. вычисления   */
              /* нетерминала OEN на пер-*/
              /* вом проходе.   Здесь   */
              /* OEN - "операт.ПЛ1-END" */
int OEN1()
{
  //fprintf(fp_out, "%s\n", "OEN1");
  //fflush(fp_out);

  char i = 0;
  FORM();                                        /* форматирование ПЛ1-опе-*/
  /* ратора END             */

  for (i = 0; i < ISYM; i++)                    /* если вторй терм опера- */
    /* тора END записан в табл*/
  {                                              /* SYM и его тип = "P",то:*/
    if (!strcmp(SYM[i].NAME, FORMT[1]) &&
      (SYM[i].TYPE == 'P') &&
      strlen(SYM[i].NAME) ==
      strlen(FORMT[1]))
      return 0;                                    /* успешное завершение    */
    /* программы              */
  }

  return 1;                                       /* иначе завершение прог- */
  /* раммы по ошибке        */
}

/*..........................................................................*/

              /* п р о г р а м м а      */
              /* семантич. вычисления   */
              /* нетерминала OPA на пер-*/
              /* вом проходе.   Здесь   */
              /* OPA - "операт.присваи- */
              /* вания арифметический   */
int OPA1()
{
  //fprintf(fp_out, "%s\n", "OPA1");
  //fflush(fp_out);

  return 0;
}

/*..........................................................................*/

              /* п р о г р а м м а      */
              /* семантич. вычисления   */
              /* нетерминала OPR на пер-*/
              /* вом проходе.   Здесь   */
              /* OPR - "операт.ПЛ1-PROC"*/
int OPR1()
{
  //fprintf(fp_out, "%s\n", "OPR1");
  //fflush(fp_out);

  FORM();                                        /* форматируем оператор   */
  /* ПЛ1 PROC               */

  strcpy(SYM[ISYM].NAME, FORMT[0]);          /* перепишем имя ПЛ1-прог-*/
  /* раммы в табл. SYM,     */

  SYM[ISYM].TYPE = 'P';                        /* установим тип этого    */
  /* имени = 'P'            */
  SYM[ISYM++].RAZR[0] = '\x0';                  /* установим разрядность  */
  /* равной 0               */

  return 0;                                       /* успешное завершение    */
  /* программы              */
}

/*..........................................................................*/

              /* п р о г р а м м а      */
              /* семантич. вычисления   */
              /* нетерминала PRO на пер-*/
              /* вом проходе.   Здесь   */
              /* PRO - "программа"      */

int PRO1()
{
  //fprintf(fp_out, "%s\n", "PRO1");
  //fflush(fp_out);

  return 0;
}

/*..........................................................................*/

              /* п р о г р а м м а      */
              /* семантич. вычисления   */
              /* нетерминала RZR на пер-*/
              /* вом проходе.   Здесь   */
              /* RZR - "разрядность"    */

int RZR1()
{
  //fprintf(fp_out, "%s\n", "RZR1");
  //fflush(fp_out);

  return 0;
}

/*..........................................................................*/

              /* п р о г р а м м а      */
              /* семантич. вычисления   */
              /* нетерминала TEL на пер-*/
              /* вом проходе.   Здесь   */
              /* TEL - "тело программы" */

int TEL1()
{
  //fprintf(fp_out, "%s\n", "TEL1");
  //fflush(fp_out);

  return 0;
}

/*..........................................................................*/

              /* п р о г р а м м а      */
              /* семантич. вычисления   */
              /* нетерминала ZNK на пер-*/
              /* вом проходе.   Здесь   */
              /* ZNK - "знак операции"  */

int ZNK1()
{
  return 0;
}

// Li

int DCF1()
{
  return 0;
}

int DCF2()
{
  //char RAB[20];
  //FORM();
  //for (int i = 0; i < ISYM; i++) 
  //{
  //  if (isalpha(SYM[i].NAME[0]))
  //  {
  //    if (SYM[i].TYPE == 'D')
  //    {
  //      char op[20] = "PL6\'";  
  //      strcat(op, SYM[i].INIT);
  //      strcat(op, "\'");       

  //      // Вызов новой функции ZKARD2 для записи в ASSTXT
  //      ZKARD2(SYM[i].NAME, "DC", op, "Initialization decimal");
  //    }
  //  }
  //}
  return 0;
}