/*
 ***** STARTING the compiler file from a high-level language
 */

/*
 ***** Block of macro definition declarations
 */

#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <stdlib.h>

void printNear(int I,int R,char* str)
{
    int start=I-R;
    int end=I+R;
    if(start<0){start=0;}
    int len=strlen(str);
    if(end>len){end=len;}
    for(;start<end;start++)
    {
        printf("%c",str[start]);
    }
    printf("\n");
}

/* front */
/* dimensions: */
#define MAXNISXTXT 50                             /* - source text;  */
#define NSINT     301                             /* - syntax rules table;  */
#define NCEL       20                             /* - stack of goals;  */
#define NDST      500                             /* - stack of achievements;  */
#define NVXOD      53                             /* - input table;  */
#define NSTROKA   200                             /* - dense text lines;  */
#define NNETRM     16                             /* - list of non-terminals;  */
#define MAXLTXT    50                             /* - output text;  */
#define MAXFORMT   30                             /* - formatted information  */
/* tolerated frag- */
/* ment of the original text; */
#define NSYM      100                             /* - tables of names and labels */

/*
 ***** Compiler DATABSE
 */

/*
 ***** Array declaration block with source text
 */

int NISXTXT;                                      /* длина массива          */
char ISXTXT [MAXNISXTXT][80];                     /* тело массива           */

/*
 ***** Block for declaration of operating variables
 */

int I1,I2,I3,I4;                                  /* счетчики циклов        */

char PREDSYM = ' ';                               /*последний обработанный  */
/*символ в уплотненном    */
/*исходном тексте         */

char STROKA [ NSTROKA ];                          /*место хранения уплотнен-*/
/*ного исходного текста   */

int I,J,K,L;                                      /*текущие индексы соответ-*/
/*specifically in: */
/*  - condensed text; */
/*  - table of grammatical rules; */
/*  - stack of delivered */
/*goals; */
/*  - stack of achieved */
/*goals; */

union                                             /* template for generation  */
{                                                 /* write output file */
    char BUFCARD [80];                            /* in IBM 370 ASSEMBLY  */
    struct
    {
        char METKA   [8];
        char PROB1;
        char OPERAC  [5];
        char PROB2;
        char OPERAND [12];
        char PROB3;
        char COMM    [52];
    } _BUFCARD;
} ASS_CARD;

char ASSTXT [ MAXLTXT ][80];                      /*массив для хранения     */
/*выходного текста на     */
/*АССЕМБЛЕРЕ IBM 370      */

int IASSTXT;                                      /*индекс выходного массива*/

char FORMT [MAXFORMT] [9];                        /*массив для форматирован-*/
/*ного  (в виде последова-*/
/*тельности 9-ти позицион-*/
/*ных строк-лексем) пред- */
/*ставления интерпретиру- */
/*емого фрагмента исходно-*/
/*го плотного текста      */

int IFORMT;                                       /*индекс форматированного */
/*  array               */
/*
 ***** Database table declaration block
 */

/*
 ***** Table used as a store (stack) of achievements
 */

struct
{
    char DST1 [ 4 ];
    int DST2;
    int DST3;
    int DST4;
    int DST5;
} DST [ NDST ];

/*
 ***** Table used as a store (stack) of targets
 */

struct
{
    char CEL1 [ 4 ];
    int CEL2;
    int CEL3;
} CEL [ NCEL ];

/*
 ***** Table of syntactic rules written in recognition form,
 ***** grouped into "bushes" and presented in the form of a bidirectional
 ***** list with alternative branches
 */

struct
{
    int POSL;
    int PRED;
    char DER[4];
    int ALT;
} SINT [ NSINT ] =
/*   __________ _________ _______ _______ ______
 |  NN      :    посл : пред  :  дер  : альт |
 |__________:_________:_______:_______:______|                          */
{
    { /*.    0     .*/ -1,    -1, "***",   -1 },
    /*                                               вход с символа - 0      */
    { /*.    1     .*/ 2,     0, "0  ",    0 },
    { /*.    2     .*/ 3,     1, "CIF",    0 },
    { /*.    3     .*/ 0,     2, "*  ",    0 },
    /*                                               вход с символа - 1      */
    { /*.    4     .*/ 5,     0, "1  ",    0 },
    { /*.    5     .*/ 6,     4, "CIF",    7 },
    { /*.    6     .*/ 0,     5, "*  ",    0 },
    
    { /*.    7     .*/ 8,     4, "MAN",    0 },
    { /*.    8     .*/ 0,     7, "*  ",    0 },
    /*                                               вход с символа - 2      */
    { /*.    9     .*/ 10,     0, "2  ",    0 },
    { /*.   10     .*/ 11,     9, "CIF",    0 },
    { /*.   11     .*/ 0,    10, "*  ",    0 },
    /*                                               вход с символа - 3      */
    { /*.   12     .*/ 13,     0, "3  ",    0 },
    { /*.   13     .*/ 14,    12, "CIF",    0 },
    { /*.   14     .*/ 0,    13, "*  ",    0 },
    /*                                               вход с символа - 4      */
    { /*.   15     .*/ 16,     0, "4  ",    0 },
    { /*.   16     .*/ 17,    15, "CIF",    0 },
    { /*.   17     .*/ 0,    16, "*  ",    0 },
    /*                                               вход с символа - 5      */
    { /*.   18     .*/ 19,     0, "5  ",    0 },
    { /*.   19     .*/ 20,    18, "CIF",    0 },
    { /*.   20     .*/ 0,    19, "*  ",    0 },
    /*                                               вход с символа - 6      */
    { /*.   21     .*/ 22,     0, "6  ",    0 },
    { /*.   22     .*/ 23,    21, "CIF",    0 },
    { /*.   23     .*/ 0,    22, "*  ",    0 },
    /*                                               вход с символа - 7      */
    { /*.   24     .*/ 25,     0, "7  ",    0 },
    { /*.   25     .*/ 26,    24, "CIF",    0 },
    { /*.   26     .*/ 0,    25, "*  ",    0 },
    /*                                               вход с символа - 8      */
    { /*.   27     .*/ 28,     0, "8  ",    0 },
    { /*.   28     .*/ 29,    27, "CIF",    0 },
    { /*.   29     .*/ 0,    28, "*  ",    0 },
    /*                                               вход с символа - 9      */
    { /*.   30     .*/ 31,     0, "9  ",    0 },
    { /*.   31     .*/ 32,    30, "CIF",    0 },
    { /*.   32     .*/ 0,    31, "*  ",    0 },
    /*                                               вход с символа - A      */
    { /*.   33     .*/ 34,     0, "A  ",    0 },
    { /*.   34     .*/ 35,    33, "BUK",    0 },
    { /*.   35     .*/ 0,    34, "*  ",    0 },
    /*                                               вход с символа - B      */
    { /*.   36     .*/ 37,     0, "B  ",    0 },
    { /*.   37     .*/ 38,    36, "BUK",    0 },
    { /*.   38     .*/ 0,    37, "*  ",    0 },
    /*                                               вход с символа - C      */
    { /*.   39     .*/ 40,     0, "C  ",    0 },
    { /*.   40     .*/ 41,    39, "BUK",    0 },
    { /*.   41     .*/ 0,    40, "*  ",    0 },
    /*                                               вход с символа - D      */
    { /*.   42     .*/ 43,     0, "D  ",    0 },
    { /*.   43     .*/ 44,    42, "BUK",   45 },
    { /*.   44     .*/ 0,    43, "*  ",    0 },
    
    { /*.   45     .*/ 46,    42, "C  ",    0 },
    { /*.   46     .*/ 47,    45, "L  ",    0 },
    { /*.   47     .*/ 48,    46, "   ",    0 },
    { /*.   48     .*/ 49,    47, "IDE",    0 },
    { /*.   49     .*/ 50,    48, "   ",    0 },
    { /*.   50     .*/ 51,    49, "B  ",  187 },
    { /*.   51     .*/ 52,    50, "I  ",    0 },
    { /*.   52     .*/ 53,    51, "N  ",    0 },
    { /*.   53     .*/ 54,    52, "   ",    0 },
    { /*.   54     .*/ 55,    53, "F  ",    0 },
    { /*.   55     .*/ 56,    54, "I  ",    0 },
    { /*.   56     .*/ 57,    55, "X  ",    0 },
    { /*.   57     .*/ 58,    56, "E  ",    0 },
    { /*.   58     .*/ 59,    57, "D  ",    0 },
    { /*.   59     .*/ 60,    58, "(  ",  204 },
    { /*.   60     .*/ 61,    59, "RZR",   61 },
    { /*.   61     .*/ 62,    60, ")  ",    0 },
    { /*.   62     .*/ 63,    61, ";  ",   65 },
    { /*.   63     .*/ 64,    62, "ODC",    0 },
    { /*.   64     .*/ 0,    63, "*  ",    0 },
    
    { /*.   65     .*/ 66,    61, "I  ",    0 },
    { /*.   66     .*/ 67,    65, "N  ",    0 },
    { /*.   67     .*/ 68,    66, "I  ",    0 },
    { /*.   68     .*/ 69,    67, "T  ",    0 },
    { /*.   69     .*/ 70,    68, "(  ",    0 },
    { /*.   70     .*/ 71,    69, "LIT",    205 },
    { /*.   71     .*/ 72,    70, ")  ",    0 },
    { /*.   72     .*/ 73,    71, ";  ",    0 },
    { /*.   73     .*/ 186,    72, "ODC",    0 },
    /*                                               вход с символа - E      */
    { /*.   74     .*/ 75,     0, "E  ",    0 },
    { /*.   75     .*/ 76,    74, "N  ",   82 },
    { /*.   76     .*/ 77,    75, "D  ",    0 },
    { /*.   77     .*/ 78,    76, "   ",    0 },
    { /*.   78     .*/ 79,    77, "IPR",    0 },
    { /*.   79     .*/ 80,    78, ";  ",    0 },
    { /*.   80     .*/ 81,    79, "OEN",    0 },
    { /*.   81     .*/ 0,    80, "*  ",    0 },
    
    { /*.   82     .*/ 83,    74, "BUK",    0 },
    { /*.   83     .*/ 0,    82, "*  ",    0 },
    /*                                               вход с символа - M      */
    { /*.   84     .*/ 85,     0, "M  ",    0 },
    { /*.   85     .*/ 86,    84, "BUK",    0 },
    { /*.   86     .*/ 0,    85, "*  ",    0 },
    /*                                               вход с символа - P      */
    { /*.   87     .*/ 88,     0, "P  ",    0 },
    { /*.   88     .*/ 89,    87, "BUK",    0 },
    { /*.   89     .*/ 0,    88, "*  ",    0 },
    /*                                               вход с символа - X      */
    { /*.   90     .*/ 91,     0, "X  ",    0 },
    { /*.   91     .*/ 92,    90, "BUK",    0 },
    { /*.   92     .*/ 0,    91, "*  ",    0 },
    /*                                               вход с символа - BUK    */
    { /*.   93     .*/ 94,     0, "BUK",    0 },
    { /*.   94     .*/ 95,    93, "IDE",    0 },
    { /*    95     .*/ 0,    94, "*  ",    0 },
    /*                                               вход с символа - IDE    */
    { /*.   96     .*/ 97,     0, "IDE",    0 },
    { /*.   97     .*/ 98,    96, "BUK",  100 },
    { /*.   98     .*/ 99,    97, "IDE",    0 },
    { /*.   99     .*/ 0,    98, "*  ",    0 },
    
    { /*.  100     .*/ 101,    96, "CIF",  103 },
    { /*.  101     .*/ 102,   100, "IDE",    0 },
    { /*.  102     .*/ 0,   101, "*  ",    0 },
    
    { /*.  103     .*/ 104,    96, "IPE",  105 },
    { /*.  104     .*/ 0,   103, "*  ",    0 },
    
    { /*.  105     .*/ 106,    96, "IPR",    0 },
    { /*.  106     .*/ 0,   105, "*  ",    0 },
    /*                                               вход с символа - +      */
    { /*.  107     .*/ 108,     0, "+  ",    0 },
    { /*.  108     .*/ 109,   107, "ZNK",    0 },
    { /*.  109     .*/ 0,   108, "*  ",    0 },
    /*                                               вход с символа - -      */
    { /*.  110     .*/ 111,     0, "-  ",    0 },
    { /*.  111     .*/ 112,   110, "ZNK",    0 },
    { /*.  112     .*/ 0,   111, "*  ",    0 },
    /*                                               вход с символа - IPR    */
    { /*.  113     .*/ 114,     0, "IPR",    0 },
    { /*.  114     .*/ 115,   113, ":  ",    0 },
    { /*.  115     .*/ 116,   114, "P  ",    0 },
    { /*.  116     .*/ 117,   115, "R  ",    0 },
    { /*.  117     .*/ 118,   116, "O  ",    0 },
    { /*.  118     .*/ 119,   117, "C  ",    0 },
    { /*.  119     .*/ 120,   118, "   ",    0 },
    { /*.  120     .*/ 121,   119, "O  ",    0 },
    { /*.  121     .*/ 122,   120, "P  ",    0 },
    { /*.  122     .*/ 123,   121, "T  ",    0 },
    { /*.  123     .*/ 124,   122, "I  ",    0 },
    { /*.  124     .*/ 125,   123, "O  ",    0 },
    { /*.  125     .*/ 126,   124, "N  ",    0 },
    { /*.  126     .*/ 127,   125, "S  ",    0 },
    { /*.  127     .*/ 128,   126, "(  ",    0 },
    { /*.  128     .*/ 129,   127, "M  ",    0 },
    { /*.  129     .*/ 130,   128, "A  ",    0 },
    { /*.  130     .*/ 131,   129, "I  ",    0 },
    { /*.  131     .*/ 132,   130, "N  ",    0 },
    { /*.  132     .*/ 133,   131, ")  ",    0 },
    { /*.  133     .*/ 134,   132, ";  ",    0 },
    { /*.  134     .*/ 135,   133, "OPR",    0 },
    { /*.  135     .*/ 0,   134, "*  ",    0 },
    /*                                                вход с символа - CIF    */
    { /*.  136     .*/ 137,     0, "CIF",    0 },
    { /*.  137     .*/ 138,   136, "RZR",    0 },
    { /*.  138     .*/ 0,     0, "*  ",    0 },
    /*                                               вход с символа - RZR    */
    { /*.  139     .*/ 140,     0, "RZR",    0 },
    { /*.  140     .*/ 141,   139, "CIF",    0 },
    { /*.  141     .*/ 142,   140, "RZR",    0 },
    { /*.  142     .*/ 0,   141, "*  ",    0 },
    /*                                               вход с символа - MAN    */
    { /*.  143     .*/ 144,     0, "MAN",    0 },
    { /*.  144     .*/ 145,   143, "B  ",  147 },
    { /*.  145     .*/ 146,   144, "LIT",    0 },
    { /*.  146     .*/ 0,   145, "*  ",    0 },
    
    { /*.  147     .*/ 148,   143, "0  ",  150 },
    { /*.  148     .*/ 149,   147, "MAN",    0 },
    { /*.  149     .*/ 0,   148, "*  ",    0 },
    
    { /*.  150     .*/ 151,   143, "1  ",    0 },
    { /*.  151     .*/ 152,   150, "MAN",    0 },
    { /*.  152     .*/ 0,   151, "*  ",    0 },
    /*                                               вход с символа - IPE    */
    { /*.  153     .*/ 154,     0, "IPE",    0 },
    { /*.  154     .*/ 155,   153, "=  ",  159 },
    { /*.  155     .*/ 156,   154, "AVI",    0 },
    { /*.  156     .*/ 157,   155, ";  ",    0 },
    { /*.  157     .*/ 158,   156, "OPA",    0 },
    { /*.  158     .*/ 0,   157, "*  ",    0 },
    
    { /*.  159     .*/ 160,   153, "AVI",    0 },
    { /*.  160     .*/ 0,   159, "*  ",    0 },
    /*                                               вход с символа - LIT    */
    { /*.  161     .*/ 162,     0, "LIT",    0 },
    { /*.  162     .*/ 163,   161, "AVI",    0 },
    { /*.  163     .*/ 0,   162, "*  ",    0 },
    /*.                                              вход с символа - AVI    */
    { /*.  164     .*/ 165,     0, "AVI",    0 },
    { /*.  165     .*/ 166,   164, "ZNK",  206 },
    { /*.  166     .*/ 167,   165, "LIT",  168 },
    { /*.  167     .*/ 197,   166, "AVI",    0 },
    
    { /*.  168     .*/ 169,   165, "IPE",    0 },
    { /*.  169     .*/ 170,   168, "AVI",    0 },
    { /*.  170     .*/ 0,   169, "*  ",    0 },
    /*                                               вход с символа - OPR    */
    { /*.  171     .*/ 172,     0, "OPR",    0 },
    { /*.  172     .*/ 173,   171, "TEL",    0 },
    { /*.  173     .*/ 174,   172, "OEN",    0 },
    { /*.  174     .*/ 175,   173, "PRO",    0 },
    { /*.  175     .*/ 0,   174, "*  ",    0 },
    /*.                                              вход с символа - ODC    */
    { /*.  176     .*/ 177,     0, "ODC",    0 },
    { /*.  177     .*/ 178,   176, "TEL",    0 },
    { /*.  178     .*/ 0,   177, "*  ",    0 },
    /*.                                              вход с символа - TEL    */
    { /*.  179     .*/ 180,     0, "TEL",    0 },
    { /*.  180     .*/ 181,   179, "ODC",  183 },
    { /*.  181     .*/ 182,   180, "TEL",    0 },
    { /*.  182     .*/ 0,   181, "*  ",    0 },
    
    { /*.  183     .*/ 184,   179, "OPA",    0 },
    { /*.  184     .*/ 185,   183, "TEL",    0 },
    { /*.  185     .*/ 0,   184, "*  ",    0 },
    
    { /*.  186     .*/ 0,    73, "*  ",    0 },
    
    
    { /*.  187     .*/ 188,    49, "C  ",    201 },
    { /*.  188     .*/ 189,   187, "H  ",    0 },
    { /*.  189     .*/ 190,   188, "A  ",    0 },
    { /*.  190     .*/ 191,   189, "R  ",    0 },
    { /*.  191     .*/ 192,   190, "(  ",    0 },
    { /*.  192     .*/ 193,   191, "RZR",    0 },
    { /*.  193     .*/ 194,   192, ")  ",    0 },
    { /*.  194     .*/ 195,   193, ";  ",    0 },
    { /*.  195     .*/ 196,   194, "ODC",    0 },
    { /*.  196     .*/ 0,   195, "*  ",    0 },
    
    { /*.  197     .*/ 0,   166, "*  ",    0 },
    
    { /*.  198     .*/ 199,     0, "*  ",    0 },
    { /*.  199     .*/ 200,   198, "ZNK",    0 },
    { /*.  200     .*/ 0,     199, "*  ",    0 },
    
    //DCL B <DEC> FIXED
    { /*.  201     .*/ 202,    49, "D  ",    0 },
    { /*.  202     .*/ 203,   201, "E  ",    0 },
    { /*.  203     .*/ 53,    202, "C  ",    0 },
    
    
    //DCL B DEC FIXED <> INIT
    { /*.  204     .*/ 65,     59, "   ",    62 },
    
    
    //DCL A BIN FIXED INIT ( <33> );
    { /*.  205     .*/ 71,    70, "RZR",     0 },
    
    //C = A <=> B;
    { /*.  206     .*/ 166,   164, "=  ",    0 },
    
    //TODO add NETERMINAL
    
    
    
    
    
};

/*
 ***** Table of inputs to the “bushes” (roots) of grammar rules,
 ***** containing the type (terminality or nonterminality) of the root
 ***** characters
 */

struct
{
    char SYM [4];
    int VX;
    char TYP;
} VXOD [ NVXOD ] =
/*   __________ ___________ _____ ______
 |  NN      |    символ | вход| тип  |
 |__________|___________|_____|______|                                  */

{
    { /*.   1     .*/ "AVI", 164, 'N' },
    { /*.   2     .*/ "BUK",  93, 'N' },
    { /*.   3     .*/ "CIF", 136, 'N' },
    { /*.   4     .*/ "IDE",  96, 'N' },
    { /*.   5     .*/ "IPE", 153, 'N' },
    { /*.   6     .*/ "IPR", 113, 'N' },
    { /*.   7     .*/ "LIT", 161, 'N' },
    { /*.   8     .*/ "MAN", 143, 'N' },
    { /*.   9     .*/ "ODC", 176, 'N' },
    { /*.  10     .*/ "OEN",   0, 'N' },
    { /*.  11     .*/ "OPA",   0, 'N' },
    { /*.  12     .*/ "OPR", 171, 'N' },
    { /*.  13     .*/ "PRO",   0, 'N' },
    { /*.  14     .*/ "RZR", 139, 'N' },
    { /*.  15     .*/ "TEL", 179, 'N' },
    { /*.  16     .*/ "ZNK",   0, 'N' },
    { /*.  17     .*/ "A  ",  33, 'T' },
    { /*.  18     .*/ "B  ",  36, 'T' },
    { /*.  19     .*/ "C  ",  39, 'T' },
    { /*.  20     .*/ "D  ",  42, 'T' },
    { /*.  21     .*/ "E  ",  74, 'T' },
    { /*.  22     .*/ "M  ",  84, 'T' },
    { /*.  23     .*/ "P  ",  87, 'T' },
    { /*.  24     .*/ "X  ",  90, 'T' },
    { /*.  25     .*/ "0  ",   1, 'T' },
    { /*.  26     .*/ "1  ",   4, 'T' },
    { /*.  27     .*/ "2  ",   9, 'T' },
    { /*.  28     .*/ "3  ",  12, 'T' },
    { /*.  29     .*/ "4  ",  15, 'T' },
    { /*.  30     .*/ "5  ",  18, 'T' },
    { /*.  31     .*/ "6  ",  21, 'T' },
    { /*.  32     .*/ "7  ",  24, 'T' },
    { /*.  33     .*/ "8  ",  27, 'T' },
    { /*.  34     .*/ "9  ",  30, 'T' },
    { /*.  35     .*/ "+  ", 107, 'T' },
    { /*.  36     .*/ "-  ", 110, 'T' },
    { /*.  37     .*/ ":  ",   0, 'T' },
    { /*.  38     .*/ "I  ",   0, 'T' },
    { /*.  39     .*/ "R  ",   0, 'T' },
    { /*.  40     .*/ "N  ",   0, 'T' },
    { /*.  41     .*/ "O  ",   0, 'T' },
    { /*.  42     .*/ "T  ",   0, 'T' },
    { /*.  43     .*/ "S  ",   0, 'T' },
    { /*.  44     .*/ "(  ",   0, 'T' },
    { /*.  45     .*/ ")  ",   0, 'T' },
    { /*.  46     .*/ "   ",   0, 'T' },
    { /*.  47     .*/ ";  ",   0, 'T' },
    { /*.  48     .*/ "L  ",   0, 'T' },
    { /*.  49     .*/ "F  ",   0, 'T' },
    { /*.  50     .*/ "=  ",   0, 'T' },
    { /*.  51     .*/ "H  ",   0, 'T' },
    { /*.  52     .*/ "*  ", 198, 'T' }
};

/*
 ***** Table of the adjacency matrix - the basis for constructing the matrix
 ***** successors
 */

char TPR [ NVXOD ] [ NNETRM ] =
{
    /*
     __________ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___
     |       AVI:BUK:CIF:IDE:IPE:IPR:LIT:MAN:ODC:OEN:OPA:OPR:PRO:RZR:TEL:ZNK|
     |__________:___:___:___:___:___:___:___:___:___:___:___:___:___:___:___| */
    { /*AVI*/ 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0  },
    { /*BUK*/ 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0  },
    { /*CIF*/ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0  },
    { /*IDE*/ 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0  },
    { /*IPE*/ 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0  },
    { /*IPR*/ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0  },
    { /*LIT*/ 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0  },
    { /*MAN*/ 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0  },
    { /*ODC*/ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0  },
    { /*OEN*/ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0  },
    { /*OPA*/ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0  },
    { /*OPR*/ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0  },
    { /*PRO*/ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0  },
    { /*RZR*/ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0  },
    { /*TEL*/ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0  },
    { /*ZNK*/ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0  },
    /*
     __________ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___
     |       AVI:BUK:CIF:IDE:IPE:IPR:LIT:MAN:ODC:OEN:OPA:OPR:PRO:RZR:TEL:ZNK|
     |__________:___:___:___:___:___:___:___:___:___:___:___:___:___:___:___| */
    { /*  A*/ 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0  },
    { /*  B*/ 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0  },
    { /*  C*/ 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0  },
    { /*  D*/ 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0  },
    { /*  E*/ 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0  },
    { /*  M*/ 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0  },
    { /*  P*/ 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0  },
    { /*  X*/ 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0  },
    { /*  0*/ 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0  },
    { /*  1*/ 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0  },
    { /*  2*/ 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0  },
    { /*  3*/ 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0  },
    { /*  4*/ 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0  },
    { /*  5*/ 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0  },
    { /*  6*/ 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0  },
    { /*  7*/ 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0  },
    /*
     __________ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___
     |       AVI:BUK:CIF:IDE;IPE:IPR:LIT:MAN:ODC:OEN:OPA:OPR:PRO:RZR:TEL:ZNK|
     |__________:___:___:___:___:___:___:___:___:___:___:___:___:___:___:___| */
    { /*  8*/ 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0  },
    { /*  9*/ 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0  },
    { /*  +*/ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1  },
    { /*  -*/ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1  },
    { /*  :*/ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0  },
    { /*  I*/ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0  },
    { /*  R*/ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0  },
    { /*  N*/ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0  },
    { /*  O*/ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0  },
    { /*  T*/ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0  },
    { /*  S*/ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0  },
    { /*  (*/ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0  },
    { /*  )*/ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0  },
    { /*  ;*/ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0  },
    { /*   */ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0  },
    { /*  L*/ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0  },
    /*
     __________ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___
     |       AVI:BUK:CIF:IDE:IPE:IPR:LIT:MAN:ODC:OEN;OPA:OPR:PR0:RZR:TEL:ZNK|
     |__________:___:___:___:___:___:___:___:___:___:___:___:___:___:___:___| */
    { /*  F*/ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0  },
    { /*  =*/ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0  },
    { /*  H*/ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0  },
    { /*  **/ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1  }
    /*|_______________________________________________________________________| */
};
/*..........................................................................*/

/*
 ****** STARTING ON Source Text Processing
 */

/*..........................................................................*/

void compress_ISXTXT()                            /* Программа уплотнения   */
/* исходного текста путем */
/* удаления "лишних"      */
/* пробелов, выполняющая  */
/* роль примитивного лек- */
/* сического анализатора  */
{
    printf("compress\n");
    I3 = 0;
    for ( I1 = 0 ; I1 < NISXTXT ; I1++ )
    {
        for ( I2 = 0 ; I2 < 80 ; I2++ ) {
            
            
            if ( ISXTXT [ I1 ][ I2 ] != '\x0' )
            {
                if ( (ISXTXT [ I1 ][ I2 ] == ' ' || ISXTXT [ I1 ][ I2 ] == '\t' || ISXTXT [ I1 ][ I2 ] == '\n') &&
                    ( PREDSYM == ' ' || PREDSYM == '\t' || PREDSYM == '\n' || PREDSYM == ';' ||
                     PREDSYM == ')' || PREDSYM == ':' ||
                     PREDSYM == '('
                     )
                    )
                {
                    PREDSYM = ' ';
                    goto L2;
                }
                
                if
                    (
                     ( ISXTXT [ I1 ][ I2 ] == '+' ||
                      ISXTXT [ I1 ][ I2 ] == '-' ||
                      ISXTXT [ I1 ][ I2 ] == '=' ||
                      ISXTXT [ I1 ][ I2 ] == '(' ||
                      ISXTXT [ I1 ][ I2 ] == ')' ||
                      ISXTXT [ I1 ][ I2 ] == '*'
                      )
                     &&
                     (PREDSYM == ' ' || PREDSYM == '\t' || PREDSYM == '\n')
                     )
                {
                    I3-- ;
                    goto L1;
                }
                
                
                if ( (ISXTXT [ I1 ][ I2 ] == ' ' || ISXTXT [ I1 ][ I2 ] == '\t' || ISXTXT [ I1 ][ I2 ] == '\n') &&
                    ( PREDSYM == '+' || PREDSYM == '-' ||
                     PREDSYM == '=' || PREDSYM == '*'
                     )
                    )
                {
                    goto L2;
                }
                
            L1:
                PREDSYM = ISXTXT [ I1 ][ I2 ];
                if (PREDSYM == '\t') {
                    PREDSYM = ' ';
                }
                STROKA [ I3 ] = PREDSYM;
                //printf("123\n");
                //printf("%s", STROKA[I3]);
                //std::cout<<STROKA[I3];
                I3++ ;
                
            L2:    continue;
            }
            else
                break;
        }
    }
    STROKA [I3] = '\x0';
}

/*..........................................................................*/

void build_TPR ()                                 /* Построение таблицы     */
/* преемников из матрицы  */
/* смежности по алгоритму */
/* Варшалла               */
{
    for ( I1 = 0; I1 < NNETRM; I1++ )
    {
        for ( I2 = 0; I2 < NVXOD; I2++ )
        {
            if ( TPR [ I2 ][ I1 ] & ( I1 != I2 ) )
            {
                for ( I3 = 0; I3 < NNETRM; I3++ )
                    TPR [ I2 ][ I3 ] |= TPR [ I1 ][ I3 ];
            }
        }
    }
}

/*..........................................................................*/

void mcel ( char* T1, int T2, int T3 )            /* программа заполнения   */
{                                                 /* ячейки стека поставлен-*/
    /* ных целей              */
    strcpy ( CEL [ K ].CEL1, T1 );
    CEL [ K ].CEL2 = T2;
    CEL [ K ].CEL3 = T3;
    K++;
    //printf("%s\n", CEL [ K ].CEL1);
}

/*..........................................................................*/

void mdst ( char* T1, int T2, int T3, int T4, int T5 )
{                                                 /* программа заполнения   */
    strcpy ( DST [ L ].DST1, T1 );            /* ячейки стека достигну- */
    DST [ L ].DST2 = T2;                      /* тых целей              */
    DST [ L ].DST3 = T3;
    DST [ L ].DST4 = T4;
    DST [ L ].DST5 = T5;
    printf("%d) %s %d %d %d %d\n", L, DST [ L ].DST1, T2, T3, T4, T5);
    L++;
}


/*..........................................................................*/
/* п р о г р а м м а      */
int numb ( char* T1, int T2 )                     /* вычисления порядкового */
/* номера строки в табл.  */
/* VXOD, соответствующей  */
/* строке-параметру функц.*/
{
    int k;
    
    for ( I1 = 0; I1 < NVXOD; I1++ )
    {
        for ( k = 0; k < T2; k++ )
        {
            if ( (*(T1+k) != VXOD [ I1 ].SYM [k] ) )
                goto numb1;
        }
        if ( (VXOD [ I1 ].SYM [k] == '\x0') ||
            (VXOD [ I1 ].SYM [k] == ' '  )
            )
            return ( I1 );
    numb1:
        continue;
    }
    return -1;
}


/*..........................................................................*/
/*   п р о г р а м м а    */
/*   построения  дерева   */
/*синтаксического разбора,*/
/*выполняющая роль синтак-*/
/*сического анализатора   */
int sint_ANAL ()
{
    I4 = 0;
    
L1:    // Блок начальных установок
    
    K = 0;
    L = 0;
    I = 0;
    J = 1;
    mcel ( "PRO", I, 999 );
    
    if (!TPR [numb ( &STROKA [I], 1 )][numb ( "PRO", 3 )])
        return 1;
    
L2:  // Блок проецирования по выбранной гипотезе
    
    J = VXOD [ numb ( &STROKA [ I ], 1 ) ].VX;
    
L3:
    
    J = SINT [ J ].POSL;
    
L31:
    
    I++;
    
    if ( I > I4 )
        
        
        I4 = I;
    
    if (VXOD [ numb ( SINT [ J ].DER, 3 ) ].TYP == 'T')
    {// Блок обработки терминала
        
        if ( STROKA [ I ] == SINT [ J ].DER [ 0 ] ) {
            //printf("T: %c\n", STROKA[ I ]);
            goto L3;
        }
        else
            goto L8; //Проверка на конец грамматического правила
        
    }
    
L4: // Блок обработки нетерминалов
    
    if ( SINT [ SINT [ J ].POSL ].DER [ 0 ] == '*' )
    {
        I--;
        //printf("N: %c\n", STROKA[ I ]);
        
        
        if ( !strcmp (SINT [J].DER, CEL [K-1].CEL1 ) )
        {
            mdst ( CEL[K-1].CEL1,CEL[K-1].CEL2,CEL[K-1].CEL3,I,J );
            
            if ( !strcmp( CEL[K-1].CEL1, "PRO" ) ) {
                
                return 0;
            }
            
        L5:
            
            if (TPR [numb (CEL[K-1].CEL1, 3)] [numb (CEL[K-1].CEL1, 3)])
            {
                J = VXOD [ numb ( CEL[K-1].CEL1, 3 ) ].VX;
                goto L3;
            }
            
        L6:
            
            J = CEL[K-1].CEL3;
            K--;
            goto L3;
        }
        
        if (!TPR [numb (SINT[J].DER, 3)] [numb (CEL[K-1].CEL1, 3)])
            goto L9;
        
        mdst ( SINT[J].DER, CEL[K-1].CEL2,0,I,J );
        J = VXOD [numb (SINT[J].DER, 3)].VX;
        goto L3;
    }
    
    if (!TPR [numb (&STROKA [I], 1)] [numb (SINT[J].DER, 3)])
        goto L8;
    
    mcel ( SINT[J].DER,I,J );
    goto L2;
    
L8:  // Блок перебора гипотез
    
    I--;
    
L9:
    
    if (SINT[J].ALT != 0)
    {
        J = SINT[J].ALT;
        goto L31;
    }
    
    J = SINT[J].PRED;
    
    if
        (
	        ( VXOD [numb (SINT[J].DER, 3)].TYP == 'N' )
	        &&
	        ( SINT[J].PRED > 0 )
         )
    {
        mcel (DST[L-1].DST1, DST[L-1].DST2, DST[L-1].DST3);
        //printDST();
        
        
    L10:
        
        J = DST[L-1].DST5;
        L--;
        goto L9;
    }
    
    if
        (
	        ( VXOD [numb (SINT[J].DER, 3)].TYP == 'N' )
	        &&
	        ( SINT[J].PRED == 0 )
         )
    {
        if (!strcmp ( CEL[K-1].CEL1, DST[L-1].DST1 ) )
            goto L6;
        else
            goto L10;
    }
    
    if ( SINT[J].PRED > 0 )
        goto L8;
    
    J = CEL[K-1].CEL3;
    K--;
    //if(J==97)
    //{
    //printNear(I, 10, STROKA);
    //printf("%s\n",SINT[J].DER);
    //}
    if ( J == 999 )
        return 2;
    else
        goto L8;
    
}

/*..........................................................................*/

struct                                            /* таблица имен меток и   */
{                                                 /* переменных, заполняемая*/
    char NAME [8];                            /* на первом проходе се-  */
    char TYPE;                                /* мантического вычисления*/
    char RAZR [5];                            /* и используемая на вто- */
    char INIT [50];                           /* ром проходе семантичес-*/
} SYM [ NSYM ];                                   /* кого вычисления        */

int ISYM = 0;                                     /* текущий индекс таблицы */
/* имен                   */

char NFIL [30]="\x0";                             /* хранилище имени транс- */
/* лируемой программы     */

/*..........................................................................*/
/* п р о г р а м м а      */
/* перевода двоичной      */
/* константы из ASCIIz-ви-*/
/* да во внутреннее пред- */
/* ставление типа long int*/
long int VALUE ( char* s )
{
    long int S;
    unsigned long length = strlen(s);
    if (s[length - 1] == 'B') {
        int i;
        
        i = 0;
        S = 0;
        while ( *(s + i) != 'B' )
            
        {
            
            S <<= 1;
            if ( *(s + i) == '1' )
                S++;
            i++;
        }
    } else {
        S = atoi(s);
    }
    
    return (S);
}



/*..........................................................................*/
/* п р о г р а м м а      */
/* представления фрагмента*/
/* плотного текста в виде */
/* массива 9-ти символьных*/
/* лексем                 */
void FORM ()
{
    int i,j;
    
    for ( IFORMT = 0; IFORMT < MAXFORMT; IFORMT++ )
        memcpy ( FORMT [IFORMT], "\x0\x0\x0\x0\x0\x0\x0\x0\x0", 9 );
    
    IFORMT = 0;
    j = DST [I2].DST2;
    
FORM1:
    
    for ( i = j; i <= DST [I2].DST4+1; i++ )
    {
        if ( STROKA [i] == ':' || STROKA [i] == ' ' ||
            STROKA [i] == '(' || STROKA [i] == ')' ||
            STROKA [i] == ';' || STROKA [i] == '+' ||
            STROKA [i] == '-' || STROKA [i] == '=' ||
            STROKA [i] == '*'
            )
        {
            FORMT [IFORMT] [i-j] = '\x0';
            IFORMT++;
            j = i+1;
            goto FORM1;
        }
        else
            FORMT [IFORMT][i-j] = STROKA [i];
        
    }
    
    return;
}

/*..........................................................................*/
/* п р о г р а м м а      */
void ZKARD ()                                     /* записи очередной сгене-*/
{                                                 /* рированной записи вы-  */
    /* ходного файла в массив */
    /* ASSTXT                 */
    char i;
    memcpy ( ASSTXT [ IASSTXT ],
            ASS_CARD.BUFCARD, 80 );
    printf("%d) %s\n", IASSTXT, ASSTXT [ IASSTXT ]);
    ASSTXT[IASSTXT][79]=0;
    IASSTXT++;
    
    for ( i = 0; i < 79; i++ )
        ASS_CARD.BUFCARD [i] = ' ';
    return;
}

/*..........................................................................*/
/* п р о г р а м м а      */
/* семантич. вычисления   */
/* нетерминала AVI на пер-*/
/* вом проходе.   Здесь   */
/* AVI -   "арифм.выраж." */
int AVI1 ()
{
    return 0;
}

/*..........................................................................*/

/* п р о г р а м м а      */
/* семантич. вычисления   */
/* нетерминала BUK на пер-*/
/* вом проходе.   Здесь   */
/* BUK -   "буква"        */
int BUK1 ()
{
    return 0;
}

/*..........................................................................*/

/* п р о г р а м м а      */
/* семантич. вычисления   */
/* нетерминала CIF на пер-*/
/* вом проходе.   Здесь   */
/* CIF -   "цифра"        */
int CIF1 ()
{
    return 0;
}

/*..........................................................................*/

/* п р о г р а м м а      */
/* семантич. вычисления   */
/* нетерминала IDE на пер-*/
/* вом проходе.   Здесь   */
/* IDE -   "идентификатор"*/
int IDE1 ()
{
    return 0;
}

/*..........................................................................*/

/* п р о г р а м м а      */
/* семантич. вычисления   */
/* нетерминала IPE на пер-*/
/* вом проходе.   Здесь   */
/* IPE - "имя переменной" */
int IPE1 ()
{
    return 0;
}

/*..........................................................................*/

/* п р о г р а м м а      */
/* семантич. вычисления   */
/* нетерминала IPR на пер-*/
/* вом проходе.   Здесь   */
/* IPR -   "имя программы" */
int IPR1 ()
{
    return 0;
}

/*..........................................................................*/

/* п р о г р а м м а      */
/* семантич. вычисления   */
/* нетерминала LIT на пер-*/
/* вом проходе.   Здесь   */
/* LIT -   "литерал"      */
int LIT1 ()
{
    return 0;
}

/*..........................................................................*/

/* п р о г р а м м а      */
/* семантич. вычисления   */
/* нетерминала MAN на пер-*/
/* вом проходе.   Здесь   */
/* MAN -   "мантисса"     */
int MAN1 ()
{
    return 0;
}

/*..........................................................................*/

/* program */
/* semantic calculations */
/* non-terminal ODC on the per- */
/* in the aisle. Here */
/* ODC - "oper.PL1-DCL" */
int ODC1 ()
{
    int i;
    FORM ();                                  /* форматирование ПЛ1-опе-*/
    /* ратора DCL             */
    
    for ( i = 0; i < ISYM; i++ )              /* если фиксируем повтор- */
    {                                         /* повторное объявление   */
        if (  !strcmp ( SYM [i].NAME, FORMT [1] ) &&/* второго терма оператора*/
            strlen ( SYM [i].NAME ) == /* DCL, то                */
            strlen ( FORMT [1] )
            )
            return 6;                 /* завершение программы   */
        /* по ошибке              */
    }
    
    strcpy ( SYM [ISYM].NAME, FORMT [1] );    /* при отсутствии повтор- */
    strcpy ( SYM [ISYM].RAZR, FORMT [4] );    /* ного объявления иденти-*/
    /* фикатора запоминаем его*/
    /* вместе с разрядностью в*/
    /* табл.SYM               */
    
    if ( !strcmp ( FORMT [2], "BIN" ) &&      /* если идентификатор оп- */
        !strcmp ( FORMT [3], "FIXED" ) )/* ределен как bin fixed, */
    {
        SYM [ISYM].TYPE = 'B';            /* то устанавливаем тип   */
        /* идентификатора = 'B' и */
        goto ODC11;                       /* идем на продолжение об-*/
        /* работки, а             */
    }
    else  if (!strcmp ( FORMT [2], "DEC" )) //decimal
    {
        //TODO alloc 3 bytes for this variable
        SYM [ISYM].TYPE = 'D';            /* то устанавливаем тип   */
        /* идентификатора = 'B' и */
        goto ODC11;
    } else
    { /* иначе                  */
        SYM [ISYM].TYPE = 'U';            /* устанавливаем тип иден-*/
        /* тификатора = 'U'  и    */
        return 2;                         /* завершаем программу    */
        /* по ошибке              */
    }
    
ODC11:
    if ( !strcmp(FORMT[4], "INIT")) {
        //init without range description
        strcpy ( SYM [ISYM++].INIT, FORMT [5] ); /* ем в табл. SYM это на- */
        ISYM++;
    } else {
        //range described before init
        /* если идентификатор     */
        /* имеет начальную иници- */
        if ( !strcmp ( FORMT [5], "INIT" )  )     /* ализацию, то запомина- */
            strcpy ( SYM [ISYM++].INIT, FORMT [6] ); /* ем в табл. SYM это на- */
        /* чальное значение, а    */
        else                                      /* иначе                  */
            strcpy ( SYM [ISYM++].INIT, "0B" ); /* инициализируем иденти- */
        /* фикатор нулем          */
    }
    return 0;                                 /* успешное завешение     */
    /* программы              */
}

/*..........................................................................*/

/* п р о г р а м м а      */
/* семантич. вычисления   */
/* нетерминала OEN на пер-*/
/* вом проходе.   Здесь   */
/* OEN - "операт.ПЛ1-END" */
int OEN1 ()
{
    char i = 0;
    FORM ();                                  /* форматирование ПЛ1-опе-*/
    /* ратора END             */
    
    for ( i = 0; i < ISYM; i++ )              /* если вторй терм опера- */
    /* тора END записан в табл*/
    {                                         /* SYM и его тип = "P",то:*/
        if ( !strcmp ( SYM [i].NAME, FORMT [1] ) &&
            (SYM [i].TYPE == 'P') &&
            strlen (SYM [i].NAME) ==
            strlen ( FORMT [1] ) )
            return 0;                 /* успешное завершение    */
        /* программы              */
    }
    
    return 1;                                 /* иначе завершение прог- */
    /* раммы по ошибке        */
}

/*..........................................................................*/

/* п р о г р а м м а      */
/* семантич. вычисления   */
/* нетерминала OPA на пер-*/
/* вом проходе.   Здесь   */
/* OPA - "операт.присваи- */
/* вания арифметический   */
int OPA1 ()
{
    return 0;
}

/*..........................................................................*/

/* п р о г р а м м а      */
/* семантич. вычисления   */
/* нетерминала OPR на пер-*/
/* вом проходе.   Здесь   */
/* OPR - "операт.ПЛ1-PROC"*/
int OPR1 ()
{
    FORM ();                                  /* форматируем оператор   */
    /* ПЛ1 PROC               */
    
    strcpy ( SYM [ISYM].NAME, FORMT [0] );    /* перепишем имя ПЛ1-прог-*/
    /* раммы в табл. SYM,     */
    
    SYM [ISYM].TYPE   = 'P';                  /* установим тип этого    */
    /* имени = 'P'            */
    SYM [ISYM++].RAZR [0] = '\x0';            /* установим разрядность  */
    /* равной 0               */
    
    return 0;                                 /* успешное завершение    */
    /* программы              */
}

/*..........................................................................*/

/* п р о г р а м м а      */
/* семантич. вычисления   */
/* нетерминала PRO на пер-*/
/* вом проходе.   Здесь   */
/* PRO - "программа"      */

int PRO1 ()
{
    return 0;
}

/*..........................................................................*/

/* п р о г р а м м а      */
/* семантич. вычисления   */
/* нетерминала RZR на пер-*/
/* вом проходе.   Здесь   */
/* RZR - "разрядность"    */

int RZR1 ()
{
    return 0;
}

/*..........................................................................*/

/* п р о г р а м м а      */
/* семантич. вычисления   */
/* нетерминала TEL на пер-*/
/* вом проходе.   Здесь   */
/* TEL - "тело программы" */

int TEL1 ()
{
    return 0;
}

/*..........................................................................*/

/* п р о г р а м м а      */
/* семантич. вычисления   */
/* нетерминала ZNK на пер-*/
/* вом проходе.   Здесь   */
/* ZNK - "знак операции"  */

int ZNK1 ()
{
    return 0;
}

/*..........................................................................*/

/* п р о г р а м м а      */
/* семантич. вычисления   */
/* нетерминала AVI на вто-*/
/* ром проходе.   Здесь   */
/* AVI -   "арифм.выраж." */


int AVI2 ()
{
    char i;
    FORM ();                                  /*форматируем правую часть*/
    /*арифметического ПЛ1-опе-*/
    /*ратора присваивания     */
    
    if ( IFORMT == 1 )                        /* если правая часть одно-*/
    {                                         /* термовая, то:          */
        for ( i = 0; i < ISYM; i++ )      /* ищем этот терм в табли-*/
        {                                 /* це имен  и             */
            if ( !strcmp ( SYM [i].NAME, FORMT [0] )  &&/* если находим, то:      */
                strlen ( SYM [i].NAME ) ==
                strlen ( FORMT [0] )
                )
            {
                if ( SYM [i].TYPE == 'B' ) /* в случае типа=bin fixed*/
                {
                    
                    if ( strcmp ( SYM [i].RAZR, "15" ) /* и разрядности <= 15    */
                        <= 0 )
                        memcpy ( ASS_CARD._BUFCARD.OPERAC, /* формируем код ассембле-*/
                                "LH", 2 ); /* ровской операции LH,   */
                    else
                        memcpy ( ASS_CARD._BUFCARD.OPERAC, /* а при разрядности >15  */
                                "L", 1 ); /* формируем код ассембле-*/
                    /* ровской операции L     */
                    
                    strcpy ( ASS_CARD._BUFCARD.OPERAND, /*       формируем        */
                            "R2," );/*       первый  и        */
                    strcat ( ASS_CARD._BUFCARD.OPERAND, /* второй операнды ассемб-*/
                            FORMT [0]);/* леровской операции     */
                    
                    ASS_CARD._BUFCARD.OPERAND [ strlen /* вставляем разделитель  */
                                               ( ASS_CARD._BUFCARD.OPERAND ) ] = ' ';
                    
                    memcpy ( ASS_CARD._BUFCARD.COMM, /* и построчный коментарий*/
                            "Loading a variable into a register", 29 );
                    
                    ZKARD (); /* запомнить операцию ас- */
                    /* семблера  и            */
                    return 0; /* завершить программу    */
                }
                else
                    return 3; /* если тип терма не bin  */
                /* fixed,то выход по ошиб-*/
                /* ке                     */
            }
        }
        return 4;                         /* если терм-идентификатор*/
        /* неопределен, то выход  */
        /* по ошибке              */
    }
    else                                      /* если правая часть ариф-*/
    /* метического выражения  */
    /* двухтермовая, то:      */
    {
        for ( i = 0; i < ISYM; i++ )      /* если правый терм ариф- */
        {                                 /* метического выражения  */
            if ( !strcmp ( SYM [i].NAME, /*определен в табл.SYM,то:*/
                          FORMT [IFORMT-1] )  &&
                strlen ( SYM [i].NAME ) ==
                strlen ( FORMT [IFORMT-1] )
                )
            {
                
                
                if ( SYM [i].TYPE == 'D' ) {
                    //convert from decimal to binary
                    //L     RRAB,B
                    //ST    RRAB,BUF+5
                    //CVB   R3,BUF
                    
                    /*
                     memcpy ( ASS_CARD._BUFCARD.METKA, "", 0 );
                     memcpy ( ASS_CARD._BUFCARD.OPERAC, "LH",2 );
                     strcpy ( ASS_CARD._BUFCARD.OPERAND, "R2," );
                     strcat ( ASS_CARD._BUFCARD.OPERAND, FORMT [IFORMT-1] );
                     ZKARD ();
                     */
                    
                    
                    
                    /*
                     memcpy ( ASS_CARD._BUFCARD.METKA, "", 0 );
                     memcpy ( ASS_CARD._BUFCARD.OPERAC, "L", 1 );
                     //TODO what to do if razr will be set later after initialization?
                     strcpy ( ASS_CARD._BUFCARD.OPERAND, "RRAB," );
                     strcat ( ASS_CARD._BUFCARD.OPERAND, FORMT [IFORMT-1] );
                     strcat ( ASS_CARD._BUFCARD.OPERAND, "\n");
                     ZKARD ();
                     
                     memcpy ( ASS_CARD._BUFCARD.METKA, "", 0 );
                     memcpy ( ASS_CARD._BUFCARD.OPERAC, "ST",2 );
                     memcpy ( ASS_CARD._BUFCARD.OPERAND, "RRAB,BUF+5", 10 );
                     ZKARD ();*/
                    
                    
                    memcpy ( ASS_CARD._BUFCARD.METKA, "", 0 );
                    memcpy ( ASS_CARD._BUFCARD.OPERAC, "MVC", 3 );
                    //TODO what to do if razr will be set later after initialization?
                    strcpy ( ASS_CARD._BUFCARD.OPERAND, "BUF+5(3)," );
                    strcat ( ASS_CARD._BUFCARD.OPERAND, FORMT [IFORMT-1] );
                    strcat ( ASS_CARD._BUFCARD.OPERAND, "\n");
                    ZKARD ();
                    
                    
                    
                    memcpy ( ASS_CARD._BUFCARD.METKA, "", 0 );
                    memcpy ( ASS_CARD._BUFCARD.OPERAC, "CVB",3 );
                    memcpy ( ASS_CARD._BUFCARD.OPERAND, "R3,BUF", 6 );
                    ZKARD ();
                    /*
                     memcpy ( ASS_CARD._BUFCARD.METKA, "TRUE", 4 );
                     memcpy ( ASS_CARD._BUFCARD.OPERAC, "DC",2 );
                     memcpy ( ASS_CARD._BUFCARD.OPERAND, "H'1'", 4 );
                     ZKARD ();
                     
                     memcpy ( ASS_CARD._BUFCARD.METKA, "TRUE", 4 );
                     memcpy ( ASS_CARD._BUFCARD.OPERAC, "DC",2 );
                     memcpy ( ASS_CARD._BUFCARD.OPERAND, "H'1'", 4 );
                     ZKARD ();*/
                    
                    
                    if ( STROKA [ DST [I2].DST4 - /* если же знак операции  */
                                 strlen ( FORMT [IFORMT-1] ) ] == /* арифметического выра-  */
                        '=' )/* жения "=", то:         */
                        
                    {
                        
                        //      LH    RRAB,TRUE
                        //      CR    R2,R3
                        //      BC    7,L2      not equal
                        //      BC    15,L1     unconditional
                        //L2    LH    RRAB,FALSE
                        //L1
                        
                        memcpy ( ASS_CARD._BUFCARD.METKA, "", 0 );
                        memcpy ( ASS_CARD._BUFCARD.OPERAC, "LH", 2 );
                        memcpy ( ASS_CARD._BUFCARD.OPERAND, "RRAB,TRUE", 9 );
                        ZKARD ();
                        
                        memcpy ( ASS_CARD._BUFCARD.METKA, "", 0 );
                        memcpy ( ASS_CARD._BUFCARD.OPERAC, "CR", 2 );
                        memcpy ( ASS_CARD._BUFCARD.OPERAND, "R2,R3", 5 );
                        ZKARD ();
                        
                        memcpy ( ASS_CARD._BUFCARD.METKA, "", 0 );
                        memcpy ( ASS_CARD._BUFCARD.OPERAC, "BC", 2 );
                        memcpy ( ASS_CARD._BUFCARD.OPERAND, "7,L2", 4 );
                        ZKARD ();
                        
                        memcpy ( ASS_CARD._BUFCARD.METKA, "", 0 );
                        memcpy ( ASS_CARD._BUFCARD.OPERAC, "BC", 2 );
                        memcpy ( ASS_CARD._BUFCARD.OPERAND, "15,L1", 5 );
                        ZKARD ();
                        
                        memcpy ( ASS_CARD._BUFCARD.METKA, "L2", 2 );
                        memcpy ( ASS_CARD._BUFCARD.OPERAC, "LH", 2 );
                        memcpy ( ASS_CARD._BUFCARD.OPERAND, "RRAB,FALSE", 10 );
                        ZKARD ();
                        
                        memcpy ( ASS_CARD._BUFCARD.METKA, "L1", 2 );
                        //memcpy ( ASS_CARD._BUFCARD.OPERAC, "NOP", 3 );
                        //memcpy ( ASS_CARD._BUFCARD.OPERAND, "", 0 );
                        //ZKARD ();
                        
                        
                        
                        
                    } else {
                        
                        //error unsupported operation for decimal fixed
                        return 5;
                    }
                    
                    return 0;
                    
                }
                
                
                
                
                
                if ( SYM [i].TYPE == 'D' || SYM [i].TYPE == 'B' ) /* если тип правого опе-  */
                {           /* ранда bin fixed, то:   */
                    
                    if ( STROKA [ DST [I2].DST4 - /* если знак опер."+",то: */
                                 strlen( FORMT [IFORMT-1] ) ] == '+' )
                    {
                        if ( strcmp ( SYM [i].RAZR, "15" ) /* если разрядность прав. */
                            <= 0 ) /* операнда <= 15, то:    */
                            memcpy ( ASS_CARD._BUFCARD.OPERAC,
                                    "AH", 2 ); /* формируем код ассембле-*/
                        else /* ровской операции "AH",а*/
                            memcpy ( ASS_CARD._BUFCARD.OPERAC,
                                    "A", 1 ); /* иначе - "A"            */
                    }
                    
                    else if ( STROKA [ DST [I2].DST4 - /* если же знак операции  */
                                      strlen ( FORMT [IFORMT-1] ) ] == /* арифметического выра-  */
                             '-' )/* жения "-", то:         */
                        
                    {
                        if ( strcmp ( SYM [i].RAZR, "15" )/* при разрядности ариф-  */
                            <= 0 ) /* метич.выраж.<= 15      */
                            memcpy( ASS_CARD._BUFCARD.OPERAC,/* формируем код ассембле-*/
                                   "SH", 2 ); /* ровской операции "SH",F*/
                        else
                            memcpy( ASS_CARD._BUFCARD.OPERAC,/* иначе - "S"            */
                                   "S", 1 );
                    }
                    
                    else
                    {
                        
                        return 5; /* если знак операции не  */
                        /* "+" и не "-", то завер-*/
                        /* шение  программы  по   */
                        /* ошибке                 */
                    }
                    /* формируем:             */
                    strcpy ( ASS_CARD._BUFCARD.OPERAND, /* - первый операнд ассем-*/
                            "RRAB," );/*блеровской операции;    */
                    strcat ( ASS_CARD._BUFCARD.OPERAND, /* - второй операнд ассем-*/
                            FORMT [IFORMT-1] );/*блеровской операции;    */
                    ASS_CARD._BUFCARD.OPERAND [ strlen
                                               ( ASS_CARD._BUFCARD.OPERAND )] =/* - разделяющий пробел;  */
                    ' ';
                    memcpy ( ASS_CARD._BUFCARD.COMM,
                            "Formation of intermediate value",/* - построчный коментарий*/
                            36 );
                    ZKARD (); /* запоминание ассембле-  */
                    /* ровской операции       */
                    
                    return 0; /* успешное завершение    */
                    /* пограммы               */
                }
                else
                    
                    
                    
                    return 3; /* если тип правого опе-  */
                /* ранда арифметического  */
                /* выражения не bin fixed,*/
                /* то завершение програм- */
                /* мы по ошибке           */
            }
        }
        return 4;                         /* если правый операнд    */
        /* арифметического выраже-*/
        /*ния не определен в табл.*/
        /* SYM, то завершить про- */
        /* грамму по ошибке       */
    }
    
}

/*..........................................................................*/

/* п р о г р а м м а      */
/* семантич. вычисления   */
/* нетерминала BUK на вто-*/
/* ром проходе.   Здесь   */
/* BUK -   "буква"        */

int BUK2 ()
{
    return 0;
}

/*..........................................................................*/

/* п р о г р а м м а      */
/* семантич. вычисления   */
/* нетерминала CIF на вто-*/
/* ром проходе.   Здесь   */
/* CIF -   "цифра"        */

int CIF2 ()
{
    return 0;
}

/*..........................................................................*/


/* п р о г р а м м а      */
/* семантич. вычисления   */
/* нетерминала IDE на вто-*/
/* ром проходе.   Здесь   */
/* IDE -   "идентификатор"*/

int IDE2 ()
{
    return 0;
}


/*..........................................................................*/

/* п р о г р а м м а      */
/* семантич. вычисления   */
/* нетерминала IPE на вто-*/
/* ром проходе.   Здесь   */
/* IPE - "имя переменной" */

int IPE2 ()
{
    return 0;
}

/*..........................................................................*/

/* п р о г р а м м а      */
/* семантич. вычисления   */
/* нетерминала IPR на вто-*/
/* ром проходе.   Здесь   */
/* IPR -   "имя программы" */

int IPR2 ()
{
    return 0;
}

/*..........................................................................*/

/* п р о г р а м м а      */
/* семантич. вычисления   */
/* нетерминала LIT на вто-*/
/* ром проходе.   Здесь   */
/* LIT -   "литерал"      */

int LIT2 ()
{
    return 0;
}

/*..........................................................................*/

/* п р о г р а м м а      */
/* семантич. вычисления   */
/* нетерминала MAN на вто-*/
/* ром проходе.   Здесь   */
/* MAN -   "мантисса"     */

int MAN2 ()
{
    return 0;
}

/*..........................................................................*/

/* п р о г р а м м а      */
/* семантич. вычисления   */
/* нетерминала ODC на вто-*/
/* ром проходе.   Здесь   */
/* ODC - "операт.ПЛ1- DCL"*/

int ODC2 ()
{
    return 0;
}

/*..........................................................................*/

/* п р о г р а м м а      */
/* семантич. вычисления   */
/* нетерминала OEN на вто-*/
/* ром проходе.   Здесь   */
/* OEN - "операт.ПЛ1-END" */

/* программа    формирует */
/* эпилог ассемблеровского*/
/* эквивалента ПЛ1-прог-  */
/* раммы                  */
int OEN2 ()
{
    char RAB [20];
    char i = 0;
    FORM ();                                  /* форматируем ПЛ1-опера- */
    /* тор END                */
    
    memcpy ( ASS_CARD._BUFCARD.OPERAC, "BCR", 3 ); /* формируем код безуслов-*/
    /*ного возврата управления*/
    /* в вызывающую программу */
    
    memcpy ( ASS_CARD._BUFCARD.OPERAND,"15,14", 5 );/* операнды команды и     */
    
    memcpy ( ASS_CARD._BUFCARD.COMM,          /* поле построчного комен-*/
            "Выход из программы", 18 );/* тария                  */
    
    ZKARD ();                                 /* запомнить опреацию     */
    /* Ассемблера             */
    
    /* далее идет блок форми- */
    /* рования декларативных  */
    /* псевдоопераций DC для  */
    /* каждого идентификатора,*/
    /* попавшего в табл.SYM   */
    
    
    
    //TRUE     DC    H'1'
    memcpy ( ASS_CARD._BUFCARD.METKA, "TRUE", 4 );
    memcpy ( ASS_CARD._BUFCARD.OPERAC, "DC",2 );
    memcpy ( ASS_CARD._BUFCARD.OPERAND, "H'1'", 4 );
    ZKARD ();
    
    //FALSE    DC    H'0'
    memcpy ( ASS_CARD._BUFCARD.METKA, "FALSE", 5 );
    memcpy ( ASS_CARD._BUFCARD.OPERAC, "DC",2 );
    memcpy ( ASS_CARD._BUFCARD.OPERAND, "H'0'", 4 );
    ZKARD ();
    
    
    
    for ( i = 0; i < ISYM; i++ )
    {                                         /* если строка табл.SYM   */
        if ( isalpha ( SYM [i].NAME [0] ) ) /* содержит идентификатор,*/
        /* т.е.начинается с буквы,*/
        {                                 /* то:                    */
            if ( SYM [i].TYPE == 'B' ) /* если тип оператора bin */
            /* fixed, то:             */
            {
                /*
                //reserve bytes before binary (unnessecary in some cases)
                //         DS    0H
                memcpy ( ASS_CARD._BUFCARD.METKA, "", 0 );
                memcpy ( ASS_CARD._BUFCARD.OPERAC, "DS",2 );
                memcpy ( ASS_CARD._BUFCARD.OPERAND, "0H", 2 );
                ZKARD ();
                */
                
                strcpy ( ASS_CARD._BUFCARD.METKA, /* пишем идентификатор в  */
                        SYM [i].NAME ); /* поле метки псевдоопера-*/
                /* ции DC                 */
                ASS_CARD._BUFCARD.METKA [ strlen
                                         ( ASS_CARD._BUFCARD.METKA ) ] = ' '; /* пишем разделитель полей*/
                
                memcpy ( ASS_CARD._BUFCARD.OPERAC, /* пишем код псевдоопера- */
                        "DC", 2 ); /* ции DC                 */
                
                if ( strcmp ( SYM [i].RAZR, "15" ) <= 0 ) /* формируем операнды псе-*/
                /* вдооперации DC         */
                    strcpy ( ASS_CARD._BUFCARD.OPERAND, /* для случая полуслова   */
                            "H\'" );
                else        /* или                    */
                    
                    strcpy ( ASS_CARD._BUFCARD.OPERAND,      /* для случая слова       */ "F\'" );
                
                //Dos command
                //  strcat ( ASS_CARD._BUFCARD.OPERAND,       /* формируем цифровую     */
                //     ltoa ( VALUE (SYM [i].INIT),     /* часть операнда псевдо- */
                //         &RAB [0], 10) ); /* операции,              */
                //let's do that in Unix!
                long int val = VALUE(SYM[i].INIT);
                //printf("%d",val);
                strcat(ASS_CARD._BUFCARD.OPERAND, gcvt(val, 10, &RAB[0]));
                ASS_CARD._BUFCARD.OPERAND [ strlen /* замыкающий апостроф    */
                                           ( ASS_CARD._BUFCARD.OPERAND ) ] = '\''; /*          и             */
                
                memcpy ( ASS_CARD._BUFCARD.COMM, /* поле построчного комен-*/
                        "Defining a Variable", 22 ); /* тария                  */
                
                ZKARD ();   /* запомнить операцию     */
                /*    Ассемблера          */
            } else if (SYM[i].TYPE == 'D') {
                strcpy ( ASS_CARD._BUFCARD.METKA, /* пишем идентификатор в  */
                        SYM [i].NAME ); /* поле метки псевдоопера-*/
                /* ции DC                 */
                ASS_CARD._BUFCARD.METKA [ strlen
                                         ( ASS_CARD._BUFCARD.METKA ) ] = ' '; /* пишем разделитель полей*/
                
                memcpy ( ASS_CARD._BUFCARD.OPERAC, /* пишем код псевдоопера- */
                        "DC", 2 ); /* ции DC                 */
                
                strcpy ( ASS_CARD._BUFCARD.OPERAND,      /* для случая слова       */ "DL3\'" );
                
                //Dos command
                //  strcat ( ASS_CARD._BUFCARD.OPERAND,       /* формируем цифровую     */
                //     ltoa ( VALUE (SYM [i].INIT),     /* часть операнда псевдо- */
                //         &RAB [0], 10) ); /* операции,              */
                //let's do that in Unix!
                strcat(ASS_CARD._BUFCARD.OPERAND, gcvt(VALUE(SYM[i].INIT), 10, &RAB[0]));
                ASS_CARD._BUFCARD.OPERAND [ strlen /* замыкающий апостроф    */
                                           ( ASS_CARD._BUFCARD.OPERAND ) ] = '\''; /*          и             */
                
                memcpy ( ASS_CARD._BUFCARD.COMM, /* поле построчного комен-*/
                        "Defining a Variable", 22 ); /* тария                  */
                
                ZKARD ();   /* запомнить операцию     */
                
            }
        }
    }
    
    
    //TODO place buf to SUM (declare constant buffers only if nessecary for code)
    
    //         DS    0F
    //BUF      DC    DL8'0'
    memcpy ( ASS_CARD._BUFCARD.METKA, "", 0 );
    memcpy ( ASS_CARD._BUFCARD.OPERAC, "DS",2 );
    memcpy ( ASS_CARD._BUFCARD.OPERAND, "0F", 2 );
    ZKARD ();
    memcpy ( ASS_CARD._BUFCARD.METKA, "BUF", 3 );
    memcpy ( ASS_CARD._BUFCARD.OPERAC, "DC",2 );
    memcpy ( ASS_CARD._BUFCARD.OPERAND, "DL8'0'", 6 );
    ZKARD ();
    
    
    
    /* далее идет блок декла- */
    /* ративных ассемблеровс- */
    /* ких EQU-операторов, оп-*/
    /* ределяющих базовый и   */
    /* рабочий регистры общего*/
    /* назначения             */
    
    memcpy ( ASS_CARD._BUFCARD.METKA, "RBASE", 5 ); /* формирование EQU-псев- */
    memcpy ( ASS_CARD._BUFCARD.OPERAC, "EQU",3 ); /* дооперации определения */
    memcpy ( ASS_CARD._BUFCARD.OPERAND, "15", 2 ); /* номера базового регист-*/
    /* ра общего назначения   */
    /*           и            */
    ZKARD ();                                 /* запоминание ее         */
    
    memcpy ( ASS_CARD._BUFCARD.METKA, "RRAB", 4 ); /* формирование EQU-псев- */
    memcpy ( ASS_CARD._BUFCARD.OPERAC, "EQU",3 ); /* дооперации определения */
    memcpy ( ASS_CARD._BUFCARD.OPERAND, "5", 1 ); /* номера базового регист-*/
    /* ра общего назначения   */
    /*            и           */
    ZKARD ();                                 /* запоминание ее         */\
    
    memcpy ( ASS_CARD._BUFCARD.METKA, "R2", 2 ); /* формирование EQU-псев- */
    memcpy ( ASS_CARD._BUFCARD.OPERAC, "EQU",3 ); /* дооперации определения */
    memcpy ( ASS_CARD._BUFCARD.OPERAND, "2", 1 ); /* номера базового регист-*/
    /* ра общего назначения   */
    /*            и           */
    ZKARD ();                                 /* запоминание ее         */
    
    memcpy ( ASS_CARD._BUFCARD.METKA, "R3", 2 ); /* формирование EQU-псев- */
    memcpy ( ASS_CARD._BUFCARD.OPERAC, "EQU",3 ); /* дооперации определения */
    memcpy ( ASS_CARD._BUFCARD.OPERAND, "3", 1 ); /* номера базового регист-*/
    /* ра общего назначения   */
    /*            и           */
    ZKARD ();                                 /* запоминание ее         */
    
    
    memcpy ( ASS_CARD._BUFCARD.OPERAC, "END", 3 ); /* формирование кода ас-  */
    /* семблеровской псевдо-  */
    /* операции END,          */
    i = 0;
    
    while ( FORMT [1][i] != '\x0' )           /* ее операнда            */
        ASS_CARD._BUFCARD.OPERAND [i] = FORMT [1][i++]; /*         и              */
    
    memcpy ( ASS_CARD._BUFCARD.COMM,          /* построчного коментария */
            "End of program", 15 );
    
    ZKARD ();                                 /* запоминание псевдоопе- */
    /* рации                  */
    
    return 0;                                 /* завершение программы   */
}

/*..........................................................................*/

/* program*/
/* semantic calculations*/
/* non-terminal OPA to VTO*/
/* rum aisle. Here*/
/* OPA - "operational assignment"*/
/* Vania arithmetic*/

int OPA2 ()
{
    int i;
    
    FORM ();                                  /*форматируем ПЛ1-оператор*/
    /*присваивания арифметич. */
    
    for ( i = 0; i < ISYM; i++ )
    {                                         /* если идентификатор пра-*/
        /* вой части оператора оп-*/
        if ( !strcmp ( SYM [i].NAME, FORMT [0] )  &&/* ределен ранее через    */
            strlen ( SYM [i].NAME ) == /* оператор DCL, то:      */
            strlen ( FORMT [0] )
            )
        {
            if ( SYM [i].TYPE == 'B' ) /* если этот идентификатор*/
            {                   /* имеет тип bin fixed,то:*/
                
                if ( strcmp ( SYM [i].RAZR, "15" ) /* если bin fixed (15),то:*/
                    <= 0 )
                    memcpy ( ASS_CARD._BUFCARD.OPERAC, /* сформировать команду   */
                            "STH", 3 ); /* записи полуслова       */
                
                else        /* иначе:                 */
                    memcpy ( ASS_CARD._BUFCARD.OPERAC, /* команду записи слова   */
                            "ST", 2 );
                
                strcpy ( ASS_CARD._BUFCARD.OPERAND, /*       доформировать    */
                        "RRAB," );/*          операнды      */
                
                strcat ( ASS_CARD._BUFCARD.OPERAND, /*           команды      */
                        FORMT [0]);
                ASS_CARD._BUFCARD.OPERAND [ strlen /*              и         */
                                           ( ASS_CARD._BUFCARD.OPERAND ) ] = ' ';
                
                memcpy ( ASS_CARD._BUFCARD.COMM, /* построчный коментарий  */
                        "Generating the value of an arithmetic expression",
                        37 );
                ZKARD ();   /* запомнить операцию     */
                /* Ассемблера  и          */
                return 0;   /* завершить программу    */
            }
            
            else                /* если идентификатор не  */
            /* имеет тип bin fixed,то:*/
                return 3;   /* завершение с диагности-*/
            /* кой ошибки             */
        }
    }
    return 4;                                 /* если идентификатор ра- */
    /* нее не определен через */
    /* ПЛ1-оператор DCL,то за-*/
    /* вершение с диагностикой*/
    /* ошибки                 */
    
}

/*..........................................................................*/

/* program */
/* semantic calculations */
/* non-terminal OPR on second- */
/* rum aisle. Here */
/* OPR - "oper.PL1-PROC" */

/* the program generates */
/* assembler prologue */
/* equivalent to the original */
/* PL1-programs */
int OPR2 ()
{
    char i = 0;
    FORM ();                                  /* форматируем оператор   */
    /* ПЛ1 - "начало процедур-*/
    /* ного блока"            */
    while ( FORMT [0][i] != '\x0' )
        ASS_CARD._BUFCARD.METKA [i++] = FORMT [0][i]; /* нулевой терм используем*/
    /* как метку в START-псев-*/
    /* дооперации Ассемблера  */
    
    memcpy ( ASS_CARD._BUFCARD.OPERAC, "START", 5 );/* достраиваем код и опе- */
    memcpy ( ASS_CARD._BUFCARD.OPERAND, "0", 1 ); /* ранды  в  START-псевдо-*/
    memcpy ( ASS_CARD._BUFCARD.COMM,          /* операции Ассемблера    */
            "Start program", 16 );
    ZKARD ();                                 /* запоминаем карту Ассем-*/
    /* блера                  */
    
    memcpy ( ASS_CARD._BUFCARD.OPERAC, "BALR", 4 ); /* формируем BALR-операцию*/
    memcpy ( ASS_CARD._BUFCARD.OPERAND,       /* Ассемблера             */
            "RBASE,0", 7 );
    memcpy ( ASS_CARD._BUFCARD.COMM,
            "Load base register", 22 );
    ZKARD ();                                 /* и запоминаем ее        */
    
    memcpy ( ASS_CARD._BUFCARD.OPERAC, "USING", 5 );/* формируем USING-псевдо-*/
    memcpy ( ASS_CARD._BUFCARD.OPERAND,       /* операцию Ассемблера    */
            "*,RBASE", 7 );
    memcpy ( ASS_CARD._BUFCARD.COMM,
            "Set register as base", 23 );
    ZKARD ();                                 /* и запоминаем ее        */
    
    return 0;                                 /* завершить подпрограмму */
}

/*..........................................................................*/

/* program */
/* semantic calculations */
/* non-terminal PRO on auto- */
/* rum aisle. Here */
/* PRO - "program" */

int PRO2 ()                                       /*прогр.формирует выходной*/
{                                                 /*файл                    */
    
    FILE *fp;                                 /*набор                   */
    /*рабочих                 */
    /*переменных              */
    
    strcat ( NFIL, "ass" );                   /*сформировать имя выход- */
    /*ного файла              */
    
    if ( (fp = fopen ( NFIL, "wt" )) == NULL ) /*при неудачн.открыт.ф-ла */
        return (7);                       /* сообщение об ошибке    */
    
    else                                      /*иначе:                  */
        //fwrite (ASSTXT, 80, IASSTXT, fp); /* формируем тело об.файла*/
        
        for(int assi=0;assi<MAXLTXT;assi++)
        {
            ASSTXT[assi][78]='\n';
            fprintf(fp, "%s",ASSTXT[assi]);
            printf("%s",ASSTXT[assi]);
        }
    fclose ( fp );                            /*закрываем об'ектный файл*/
    return ( 0 );                             /*завершить полдпрограмму */
}

/*..........................................................................*/

/* п р о г р а м м а      */
/* семантич. вычисления   */
/* нетерминала RZR на вто-*/
/* ром проходе.   Здесь   */
/* RZR - "разрядность"    */

int RZR2 ()
{
    return 0;
}

/*..........................................................................*/

/* п р о г р а м м а      */
/* семантич. вычисления   */
/* нетерминала TEL на вто-*/
/* ром проходе.   Здесь   */
/* TEL - "тело программы" */

int TEL2 ()
{
    return 0;
}

/*..........................................................................*/

/* п р о г р а м м а      */
/* семантич. вычисления   */
/* нетерминала ZNK на вто-*/
/* ром проходе.   Здесь   */
/* ZNK - "знак операции"  */

int ZNK2 ()
{
    return 0;
}

/*..........................................................................*/

/*  п р о г р а м м а     */
/* управления абстрактной */
/* ЭВМ  -  семантического */
/* вычислителя, интерпре- */
/* тирующего абстрактную  */
/* программу, сформирован-*/
/* ную синтаксическим ана-*/
/* лизатором в стеке дос- */
/* тигнутых целей.        */

/* Суть алгоритма управле-*/
/*ния  в  последовательной*/
int gen_COD ()                                    /*интерпретации строк сте-*/
{                                                 /*ка достижений  в направ-*/
    int NOSH;                                 /*лении от дна к вершине. */
    
    int (*FUN [NNETRM][2]) () =               /*При этом каждая строка  */
    {                                         /*воспринимается как кома-*/
        { /*    1  */ AVI1, AVI2 },       /*нда абстрактной ЭВМ со  */
        { /*    2  */ BUK1, BUK2 },       /*следующими полями:      */
        { /*    3  */ CIF1, CIF2 },
        { /*    4  */ IDE1, IDE2 }, /* - DST.DST1 - код опера-*/
        { /*    5  */ IPE1, IPE2 }, /*ции;                    */
        { /*    6  */ IPR1, IPR2 },
        { /*    7  */ LIT1, LIT2 },       /* - DST.DST2 - левая гра-*/
        { /*    8  */ MAN1, MAN2 }, /*ница интерпретируемого  */
        { /*    9  */ ODC1, ODC2 }, /*фрагмента исх.текста;   */
        { /*   10  */ OEN1, OEN2 },
        { /*   11  */ OPA1, OPA2 }, /* - DST.DST4 -правая гра-*/
        { /*   12  */ OPR1, OPR2 }, /*ница интерпретируемого  */
        { /*   13  */ PRO1, PRO2 }, /*фрагмента исх.текста.   */
        { /*   14  */ RZR1, RZR2 },
        { /*   15  */ TEL1, TEL2 },
        { /*   16  */ ZNK1, ZNK2 }
    };
    
    for ( I2 = 0; I2 < L; I2++ )              /* организация первого    */
        if ( ( NOSH = FUN [               /* прохода семантического */
                           numb ( DST [I2].DST1, 3 ) /* вычисления             */
                           ][0] ()
              ) != 0
            )
            return (NOSH);            /* выход из программы     */
    /* по ошибке              */
    
    for ( I2 = 0; I2 < L; I2++ )              /* организация второго    */
        if ( ( NOSH = FUN [               /* прохода семантического */
                           numb ( DST [I2].DST1, 3 ) /* вычисления             */
                           ][1] ()
              ) != 0
            )
            return (NOSH);            /* выход из программы     */
    /* по ошибке              */
    
    return 0;                                 /* успешное завершение    */
    /* программы              */
}

/*..........................................................................*/

/*  program,    */
/* organizing sequential processing of */
/* the source text:        */
/* - lexical analyzer; */
/* - syntax analyzer; */
/* - semantic calculator */
int main (int argc, char **argv )
{                                                 /* working variables:    */
    FILE *fp;                                 /* - file pointer;   */
    char *ptr=argv[1];                        /* - pointer to the first */
    /* command line parameter */
    
    system("pwd");
    
    strcpy ( NFIL, ptr );                     /* extract the name of the translated */
    /* program from the command line */
    /* into the working field   */
    
    /* check the correctness of the command line */
    if ( argc != 2 )
        
    {                                         /* in case of an error in the command line */
        printf ("%s\n", "Error in command line"); /* output diagnostic message and */
        return 1;                           /* end translation   */
    }
    
    /* check the type of source file */
    if
        (
	        strcmp ( &NFIL [ strlen ( NFIL )-3 ], "pli" ) /* if type is not "pli", then: */
         )
        
    {
        printf ( "%s\n",                  /* output diagnostic message and */
                "Incorrect source file type" );
        return 1;                           /* end translation   */
    }
    
    
    else                                      /* if file type is "pli", then */
        
    {                                         /* try to open file and */
        if ( (fp = fopen ( NFIL, "rb" )) == NULL ) /* if file open fails */
        /* error message and  */
        {
            printf ( "%s\n",
                    "Source file not found" );
            return 1;                   /* end translation  */
        }
        
        else                              /* otherwise:                 */
        /* write the file to the array */
        /*  ISXTXT                */
        {
            for ( NISXTXT = 0; NISXTXT <= MAXNISXTXT; NISXTXT++ )
            {
                memset(ISXTXT[NISXTXT], 0, 80*sizeof(char));
                if ( fgets(ISXTXT[NISXTXT], 80, fp) == NULL )//!fread ( ISXTXT [NISXTXT], 80, 1, fp ) )
                {
                    if ( feof ( fp ) ) /* at the end of the file go to */
                        goto main1; /* label main1           */
                    else          /* on read failure        */
                    {            /* output diagnostic message     */
                        printf ( "%s\n",
                                "Error reading file with source text" );
                        return 1; /* and end translation */
                    }
                }
                for (int i=0; i<strlen(ISXTXT[NISXTXT]); i++)
                {
                    if(ISXTXT[NISXTXT][i]=='\n')
                        ISXTXT[NISXTXT][i]=0;
                }
            }
            
            printf ( "%s\n",          /* upon array overflow */
                    "Source text buffer overflow" ); /* ISXTXT output diagnostic */
            return 1;                   /* and end translation */
        }
        
    }
main1:                                            /* upon completion of reading */
    /* the source file forms */
    fclose ( fp );                            /* prefix of the output file name */
    NFIL [ strlen ( NFIL )-3 ] = '\x0';       /* for the Assembler file */
    
    memset ( ASS_CARD.BUFCARD, ' ', 80 );     /* clearing the output assembler */
    /* file line buffer */
    
    compress_ISXTXT ();                       /* lexical analysis */
    /* of the source text */
    
    build_TPR ();                             /* building the successor matrix */
    
    if ( (sint_ANAL ()) )                     /* syntax analysis */
    {                                         /* of the source text */
        STROKA [I4 +20] = '\x0';
        printf                            /* if syntax errors are found */
        (                         /* then: */
         "%s%s%s%s\n",
         "syntax error in source text -> ", /* output diagnostic message and */
         "\"...",&STROKA [I4], "...\""
         );
        printf
        (
         "%s\n", "translation aborted"
         );
        return 1;                           /* end translation   */
    }
    else                                      /* otherwise */
    {
        switch ( gen_COD () )             /* semantic calculation */
        {
            case  0:                          /* if termination code = 0, */
                /* then:                    */
                
                printf ( "%s\n",          /* - diagnostic message; */
                        "translation successfully completed" );
                return 1;                   /* - end the translation */
                
                
            case  1:                          /* if termination code = 1, */
                /* then:                    */
                printf ( "%s\n",          /* - diagnostic message; */
                        "procedure name mismatch in prologue-epilogue" );
                break;                    /* - exit to general */
                /* diagnostic message; */
                /* diagnostic */
                
            case  2:                          /* if termination code = 2, */
                /* then:                    */
                STROKA [ DST [I2].DST2 +20 ] = '\x0'; /* - diagnostic message; */
                printf ( "%s%s\n%s%s%s\n",
                        "invalid identifier type: ",
                        &FORMT [1], " in source text -> \"...",
                        &STROKA [ DST [I2].DST2 ], "...\"" );
                break;                    /* - exit to general */
                /* diagnostic */
                
            case  3:                          /* if termination code = 3, */
                /* then:                    */
                STROKA [ DST [I2].DST2 + 20 ] = '\x0'; /* - diagnostic message; */
                printf ( "%s%s\n%s%s%s\n",
                        "invalid identifier type: ",
                        &FORMT [IFORMT-1], " in source text -> \"...",
                        &STROKA [ DST [I2].DST2 ], "...\"" );
                break;                    /* -exit to general */
                /* diagnostic */
                
            case  4:                          /* if termination code = 4, */
                /* then:                    */
                STROKA [ DST [I2].DST2 + 20 ] = '\x0'; /* - diagnostic message; */
                printf ( "%s%s\n%s%s%s\n",
                        "undefined identifier: ",
                        &FORMT [IFORMT-1], " in source text -> \"...",
                        &STROKA [ DST [I2].DST2 ], "...\"" );
                break;                    /* - exit to general */
                /* diagnostic */
                
            case  5:                          /* if termination code = 5, */
                /* then:                    */
                STROKA [ DST [I2].DST2 + 20 ] = '\x0'; /* - diagnostic message; */
                printf ( "%s%c\n%s%s%s\n",
                        "invalid operation: ",
                        STROKA [ DST [I2].DST4 - strlen ( FORMT [IFORMT-1] ) ],
                        " in source text -> \"...", &STROKA [ DST [I2].DST2 ], "...\"");
                break;                    /* - exit to general */
                /* diagnostic */
                
            case  6:                          /* if termination code = 6 */
                /* then:                    */
                STROKA [ DST [I2].DST2 + 20 ] = '\x0'; /* - diagnostic message; */
                printf ( "%s%s\n%s%s%s\n",
                        "redeclaration of identifier: ",
                        &FORMT [1], " in source text -> \"...",
                        &STROKA [ DST [I2].DST2 ], "...\"" );
                break;                    /* - exit to general */
                /* diagnostic */
                
        }
        
    }
    
    printf ( "%s\n", "translation aborted" ); /* general diagnostic */
    return 0;
}
/*..........................................................................*/